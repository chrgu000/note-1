<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>零零散散</title>
    <link>/categories/scala/index.xml</link>
    <description>Recent content on 零零散散</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="/categories/scala/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Scala实战</title>
      <link>/post/bigdata/scala/scala%E5%AE%9E%E6%88%98/</link>
      <pubDate>Fri, 07 Apr 2017 15:06:47 +0000</pubDate>
      
      <guid>/post/bigdata/scala/scala%E5%AE%9E%E6%88%98/</guid>
      <description>&lt;div id=&#34;toc&#34; class=&#34;toc&#34;&gt;
&lt;div id=&#34;toctitle&#34;&gt;Scala实战&lt;/div&gt;
&lt;ul class=&#34;sectlevel1&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_scala实战&#34;&gt;1. Scala实战&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_项目概述&#34;&gt;2. 项目概述&lt;/a&gt;
&lt;ul class=&#34;sectlevel2&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_需求&#34;&gt;2.1. 需求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_akka简介&#34;&gt;2.2. Akka简介&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_项目实现&#34;&gt;3. 项目实现&lt;/a&gt;
&lt;ul class=&#34;sectlevel2&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_架构图&#34;&gt;3.1. 架构图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_重要类介绍&#34;&gt;3.2. 重要类介绍&lt;/a&gt;
&lt;ul class=&#34;sectlevel3&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_actorsystem&#34;&gt;3.2.1. ActorSystem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_actor&#34;&gt;3.2.2. Actor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_master类&#34;&gt;3.3. Master类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_worker类&#34;&gt;3.4. Worker类&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_scala实战&#34;&gt;1. Scala实战&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_项目概述&#34;&gt;2. 项目概述&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_需求&#34;&gt;2.1. 需求&lt;/h3&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;目前大多数的分布式架构底层通信都是通过RPC实现的，RPC框架非常多，比如前我们学过的Hadoop项目的RPC通信框架，但是Hadoop在设计之初就是为了运行长达数小时的批量而设计的，在某些极端的情况下，任务提交的延迟很高，所有Hadoop的RPC显得有些笨重。

Spark 的RPC是通过Akka类库实现的，Akka用Scala语言开发，基于Actor并发模型实现，Akka具有高可靠、高性能、可扩展等特点，使用Akka可以轻松实现分布式RPC功能。&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_akka简介&#34;&gt;2.2. Akka简介&lt;/h3&gt;
&lt;div class=&#34;quoteblock&#34;&gt;
&lt;blockquote&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Akka基于Actor模型，提供了一个用于构建可扩展的（Scalable）、弹性的（Resilient）、快速响应的（Responsive）应用程序的平台。&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&#34;dlist&#34;&gt;
&lt;dl&gt;
&lt;dt class=&#34;hdlist1&#34;&gt;Actor模型&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;在计算机科学领域，Actor模型是一个并行计算（Concurrent Computation）模型，它把actor作为并行计算的基本元素来对待：为响应一个接收到的消息，一个actor能够自己做出一些决策，如创建更多的actor，或发送更多的消息，或者确定如何去响应接收到的下一个消息。&lt;/p&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/img/scala/2017-04-07_151513.png&#34; alt=&#34;2017 04 07 151513&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/dd&gt;
&lt;dt class=&#34;hdlist1&#34;&gt;Actor&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;是Akka中最核心的概念，它是一个封装了状态和行为的对象，Actor之间可以通过交换消息的方式进行通信，每个Actor都有自己的收件箱（Mailbox）。通过Actor能够简化锁及线程管理，可以非常容易地开发出正确地并发程序和并行系统，Actor具有如下特性：&lt;/p&gt;
&lt;div class=&#34;olist arabic&#34;&gt;
&lt;ol class=&#34;arabic&#34;&gt;
&lt;li&gt;
&lt;p&gt;提供了一种高级抽象，能够简化在并发（Concurrency）/并行（Parallelism）应用场景下的编程开发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供了异步非阻塞的、高性能的事件驱动编程模型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;超级轻量级事件处理（每GB堆内存几百万Actor）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_项目实现&#34;&gt;3. 项目实现&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_架构图&#34;&gt;3.1. 架构图&lt;/h3&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/img/scala/2017-04-07_151523.png&#34; alt=&#34;2017 04 07 151523&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_重要类介绍&#34;&gt;3.2. 重要类介绍&lt;/h3&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_actorsystem&#34;&gt;3.2.1. ActorSystem&lt;/h4&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;在 &lt;strong&gt;Akka&lt;/strong&gt; 中， &lt;strong&gt;ActorSystem&lt;/strong&gt; 是一个重量级的结构，他需要分配多个线程，所以在实际应用中， &lt;strong&gt;ActorSystem&lt;/strong&gt; 通常是一个单例对象，我们可以使用这个 &lt;strong&gt;ActorSystem&lt;/strong&gt; 创建很多 &lt;strong&gt;Actor&lt;/strong&gt; 。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_actor&#34;&gt;3.2.2. Actor&lt;/h4&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;在Akka中，Actor负责通信，在Actor中有一些重要的生命周期方法。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;olist arabic&#34;&gt;
&lt;ol class=&#34;arabic&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;preStart()&lt;/strong&gt; 方法：该方法在 &lt;strong&gt;Actor&lt;/strong&gt; 对象构造方法执行后执行，整个 &lt;strong&gt;Actor&lt;/strong&gt; 生命周期中仅执行一次。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;receive()&lt;/strong&gt; 方法：该方法在 &lt;strong&gt;Actor&lt;/strong&gt; 的 &lt;strong&gt;preStart&lt;/strong&gt; 方法执行完成后执行，用于接收消息，会被反复执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_master类&#34;&gt;3.3. Master类&lt;/h3&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;import scala.concurrent.duration._
import akka.actor.{Props, ActorSystem, Actor}
import akka.actor.Actor.Receive
import com.typesafe.config.ConfigFactory

import scala.collection.mutable

/**
  * Master为整个集群中的主节点
  * Master继承了Actor
  */
class Master extends Actor{

  //保存WorkerID和Work信息的map
  val idToWorker = new mutable.HashMap[String, WorkerInfo]
  //保存所有Worker信息的Set
  val workers = new mutable.HashSet[WorkerInfo]
  //Worker超时时间
  val WORKER_TIMEOUT = 10 * 1000
  //重新receive方法

  //导入隐式转换，用于启动定时器
  import context.dispatcher

  //构造方法执行完执行一次
  override def preStart(): Unit = {
    //启动定时器，定时执行
    context.system.scheduler.schedule(0 millis, WORKER_TIMEOUT millis, self, CheckOfTimeOutWorker)
  }

  //该方法会被反复执行，用于接收消息，通过case class模式匹配接收消息
  override def receive: Receive = {
    //Worker向Master发送的注册消息
    case RegisterWorker(id, workerHost, memory, cores) =&amp;gt; {
      if(!idToWorker.contains(id)) {
        val worker = new WorkerInfo(id, workerHost, memory, cores)
        workers.add(worker)
        idToWorker(id) = worker
        sender ! RegisteredWorker(&#34;192.168.10.1&#34;)
      }
    }

    //Worker向Master发送的心跳消息
    case HeartBeat(workerId) =&amp;gt; {
      val workerInfo = idToWorker(workerId)
      workerInfo.lastHeartbeat = System.currentTimeMillis()
    }

    //Master自己向自己发送的定期检查超时Worker的消息
    case CheckOfTimeOutWorker =&amp;gt; {
      val currentTime = System.currentTimeMillis()
      val toRemove = workers.filter(w =&amp;gt; currentTime - w.lastHeartbeat &amp;gt;WORKER_TIMEOUT).toArray
      for(worker &amp;lt;- toRemove){
        workers -= worker
        idToWorker.remove(worker.id)
      }
      println(&#34;worker size: &#34;+ workers.size)
    }
  }
}

object Master {
  //程序执行入口
  def main(args: Array[String]) {

    val host = &#34;192.168.10.1&#34;
    val port = 8888
    //创建ActorSystem的必要参数
    val configStr =
      s&#34;&#34;&#34;
         |akka.actor.provider = &#34;akka.remote.RemoteActorRefProvider&#34;
         |akka.remote.netty.tcp.hostname = &#34;$host&#34;
         |akka.remote.netty.tcp.port = &#34;$port&#34;
&#34;&#34;&#34;.stripMargin
    val config = ConfigFactory.parseString(configStr)
    //ActorSystem是单例的，用来创建Actor
    val actorSystem = ActorSystem.create(&#34;MasterActorSystem&#34;, config)
    //启动Actor，Master会被实例化，生命周期方法会被调用
    actorSystem.actorOf(Props[Master], &#34;Master&#34;)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_worker类&#34;&gt;3.4. Worker类&lt;/h3&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;import java.util.UUID
import scala.concurrent.duration._
import akka.actor.{ActorSelection, Props, ActorSystem, Actor}
import akka.actor.Actor.Receive
import com.typesafe.config.ConfigFactory

/**
  * Worker为整个集群的从节点
  * Worker继承了Actor
  */
class Worker extends Actor{

  //Worker端持有Master端的引用（代理对象）
  var master: ActorSelection = null
  //生成一个UUID，作为Worker的标识
  val id = UUID.randomUUID().toString

  //构造方法执行完执行一次
  override def preStart(): Unit = {
    //Worker向MasterActorSystem发送建立连接请求
    master = context.system.actorSelection(&#34;akka.tcp://MasterActorSystem@192.168.10.1:8888/user/Master&#34;)
    //Worker向Master发送注册消息
    master ! RegisterWorker(id, &#34;192.168.10.1&#34;, 10240, 8)
  }

  //该方法会被反复执行，用于接收消息，通过case class模式匹配接收消息
  override def receive: Receive = {
    //Master向Worker的反馈信息
    case RegisteredWorker(masterUrl) =&amp;gt; {
      import context.dispatcher
      //启动定时任务，向Master发送心跳
      context.system.scheduler.schedule(0 millis, 5000 millis, self, SendHeartBeat)
    }

    case SendHeartBeat =&amp;gt; {
      println(&#34;worker send heartbeat&#34;)
      master ! HeartBeat(id)
    }
  }
}

object Worker {
  def main(args: Array[String]) {
    val clientPort = 2552
    //创建WorkerActorSystem的必要参数
    val configStr =
      s&#34;&#34;&#34;
         |akka.actor.provider = &#34;akka.remote.RemoteActorRefProvider&#34;
         |akka.remote.netty.tcp.port = $clientPort
&#34;&#34;&#34;.stripMargin
    val config = ConfigFactory.parseString(configStr)
    val actorSystem = ActorSystem(&#34;WorkerActorSystem&#34;, config)
    //启动Actor，Master会被实例化，生命周期方法会被调用
    actorSystem.actorOf(Props[Worker], &#34;Worker&#34;)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Scala高级特性</title>
      <link>/post/bigdata/scala/scala%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</link>
      <pubDate>Fri, 07 Apr 2017 14:47:38 +0000</pubDate>
      
      <guid>/post/bigdata/scala/scala%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</guid>
      <description>&lt;div id=&#34;toc&#34; class=&#34;toc&#34;&gt;
&lt;div id=&#34;toctitle&#34;&gt;Scala高级特性&lt;/div&gt;
&lt;ul class=&#34;sectlevel1&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_高阶函数&#34;&gt;1. 高阶函数&lt;/a&gt;
&lt;ul class=&#34;sectlevel2&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_概念&#34;&gt;1.1. 概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_作为值的函数&#34;&gt;1.2. 作为值的函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_匿名函数&#34;&gt;1.3. 匿名函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_将方法转换成函数&#34;&gt;1.4. 将方法转换成函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_柯里化&#34;&gt;1.5. 柯里化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_例子&#34;&gt;1.6. 例子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_隐式转换和隐式参数&#34;&gt;2. 隐式转换和隐式参数&lt;/a&gt;
&lt;ul class=&#34;sectlevel2&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_概念_2&#34;&gt;2.1. 概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_作用&#34;&gt;2.2. 作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_隐式转换函数&#34;&gt;2.3. 隐式转换函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_隐式转换例子&#34;&gt;2.4. 隐式转换例子&lt;/a&gt;
&lt;ul class=&#34;sectlevel3&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_隐式转换变量值&#34;&gt;2.4.1. 隐式转换变量值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_隐式转换方法&#34;&gt;2.4.2. 隐式转换方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_高阶函数&#34;&gt;1. 高阶函数&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_概念&#34;&gt;1.1. 概念&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Scala混合了面向对象和函数式的特性，我们通常将可以做为参数传递到方法中的表达式叫做函数。在函数式编程语言中，函数是“头等公民”，高阶函数包含：作为值的函数、匿名函数、闭包、柯里化等等。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_作为值的函数&#34;&gt;1.2. 作为值的函数&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;可以像任何其他数据类型一样被传递和操作的函数，每当你想要给算法传入具体动作时这个特性就会变得非常有用。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/img/scala/2017-04-07_145546.png&#34; alt=&#34;2017 04 07 145546&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;定义函数时格式：val 变量名 =(输入参数类型和个数)&amp;#8658;函数实现和返回值类型和个数
“=”表示将函数赋给一个变量
“&amp;#8658;”左面表示输入参数名称、类型和个数，右边表示函数的实现和返回值类型和参数个数&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_匿名函数&#34;&gt;1.3. 匿名函数&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;在Scala中，你不需要给每一个函数命名，没有将函数赋给变量的函数叫做匿名函数&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/img/scala/2017-04-07_145555.png&#34; alt=&#34;2017 04 07 145555&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;由于Scala可以自动推断出参数的类型，所有可以写的跟精简一些&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/img/scala/2017-04-07_145603.png&#34; alt=&#34;2017 04 07 145603&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;还记得神奇的下划线吗？这才是终极方式&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/img/scala/2017-04-07_145612.png&#34; alt=&#34;2017 04 07 145612&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_将方法转换成函数&#34;&gt;1.4. 将方法转换成函数&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;在Scala中，方法和函数是不一样的，最本质的区别是函数可以做为参数传递到方法中
但是方法可以被转换成函数，神奇的下划线又出场了&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/img/scala/2017-04-07_145620.png&#34; alt=&#34;2017 04 07 145620&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_柯里化&#34;&gt;1.5. 柯里化&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;柯里化指的是将原来接受两个参数的方法变成新的接受一个参数的方法的过程&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/img/scala/2017-04-07_145627.png&#34; alt=&#34;2017 04 07 145627&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_例子&#34;&gt;1.6. 例子&lt;/h3&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;object FunDemo {
  def main(args: Array[String]) {
    def f2(x: Int) = x * 2
    val f3 = (x: Int) =&amp;gt; x * 3
    val f4: (Int) =&amp;gt; Int = { x =&amp;gt; x * 4 }
    val f4a: (Int) =&amp;gt; Int = _ * 4
    val f5 = (_: Int) * 5
    val list = List(1, 2, 3, 4, 5)
    var new_list: List[Int] = null
    //第一种：最直观的方式 (Int) =&amp;gt; Int
    //new_list = list.map((x: Int) =&amp;gt; x * 3)

    //第二种：由于map方法知道你会传入一个类型为(Int) =&amp;gt; Int的函数，你可以简写
    //new_list = list.map((x) =&amp;gt; x * 3)

    //第三种：对于只有一个参数的函数，你可以省去参数外围的()
    //new_list = list.map(x =&amp;gt; x * 3)

    //第四种：(终极方式)如果参数在=&amp;gt;右侧只出现一次，可以使用_
    new_list = list.map(_ * 3)

    new_list.foreach(println(_))

    var a = Array(1,2,3)
    a.map(_* 3)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_隐式转换和隐式参数&#34;&gt;2. 隐式转换和隐式参数&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_概念_2&#34;&gt;2.1. 概念&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;隐式转换和隐式参数是Scala中两个非常强大的功能，利用隐式转换和隐式参数，你可以提供优雅的类库，对类库的使用者隐匿掉那些枯燥乏味的细节。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_作用&#34;&gt;2.2. 作用&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;隐式的对类的方法进行增强，丰富现有类库的功能&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_隐式转换函数&#34;&gt;2.3. 隐式转换函数&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;是指那种以implicit关键字声明的带有单个参数的函数&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_隐式转换例子&#34;&gt;2.4. 隐式转换例子&lt;/h3&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;//隐式的增强File类的方法
class RichFile(val from: File) {
  def read = Source.fromFile(from.getPath).mkString
}

object RichFile {
  //隐式转换方法
  implicit def file2RichFile(from: File) = new RichFile(from)

}

object MainApp{
  def main(args: Array[String]): Unit = {
    //导入隐式转换
    import RichFile._
    //import RichFile.file2RichFile
    println(new File(&#34;c://words.txt&#34;).read)

  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;import java.awt.GridLayout

object ImplicitContext {

  //implicit def girl2Ordered(g : Girl) = new Ordered[Girl]{
  //  override def compare(that: Girl): Int = if (g.faceValue &amp;gt; that.faceValue) 1 else -1
  //}

  implicit object OrderingGirl extends Ordering[Girl] {
    override def compare(x: Girl, y: Girl): Int = if (x.faceValue &amp;gt; y.faceValue) 1 else -1
  }

}

class Girl(var name: String, var faceValue: Double) {
  override def toString: String = s&#34;name : $name, faveValue : $faceValue&#34;
}

//class MissRight[T &amp;lt;% Ordered[T]](f: T, s: T){
//  def choose() = if(f &amp;gt; s) f else s
//}
//class MissRight[T](f: T, s: T){
//  def choose()(implicit ord: T =&amp;gt; Ordered[T]) = if (f &amp;gt; s) f else s
//}

class MissRight[T: Ordering](val f: T, val s: T) {
  def choose()(implicit ord: Ordering[T]) = if (ord.gt(f, s)) f else s
}

object MissRight {
  def main(args: Array[String]) {
    import ImplicitContext.OrderingGirl
    val g1 = new Girl(&#34;yuihatano&#34;, 99)
    val g2 = new Girl(&#34;jzmb&#34;, 98)
    val mr = new MissRight(g1, g2)
    val result = mr.choose()
    println(result)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_隐式转换变量值&#34;&gt;2.4.1. 隐式转换变量值&lt;/h4&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/svg/scala-implic.svg&#34; alt=&#34;scala implic&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_隐式转换方法&#34;&gt;2.4.2. 隐式转换方法&lt;/h4&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/svg/scala-implic2.svg&#34; alt=&#34;scala implic2&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Scala Actor编程</title>
      <link>/post/bigdata/scala/scala-Actor%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Wed, 05 Apr 2017 09:47:03 +0000</pubDate>
      
      <guid>/post/bigdata/scala/scala-Actor%E7%BC%96%E7%A8%8B/</guid>
      <description>&lt;div id=&#34;toc&#34; class=&#34;toc&#34;&gt;
&lt;div id=&#34;toctitle&#34;&gt;Scala Actor编程&lt;/div&gt;
&lt;ul class=&#34;sectlevel1&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_scala_actor编程&#34;&gt;1. Scala Actor编程&lt;/a&gt;
&lt;ul class=&#34;sectlevel2&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_什么是scala_actor&#34;&gt;1.1. 什么是Scala Actor&lt;/a&gt;
&lt;ul class=&#34;sectlevel3&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_概念&#34;&gt;1.1.1. 概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_传统java并发编程与scala_actor编程的区别&#34;&gt;1.1.2. 传统java并发编程与Scala Actor编程的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_actor方法执行顺序&#34;&gt;1.1.3. Actor方法执行顺序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_发送消息的方式&#34;&gt;1.1.4. 发送消息的方式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_actor实战&#34;&gt;1.2. Actor实战&lt;/a&gt;
&lt;ul class=&#34;sectlevel3&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_第一个例子&#34;&gt;1.2.1. 第一个例子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_第二个例子_可以不断地接收消息&#34;&gt;1.2.2. 第二个例子（可以不断地接收消息）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_第三个例子_react方式会复用线程_比receive更高效&#34;&gt;1.2.3. 第三个例子（react方式会复用线程，比receive更高效）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_第四个例子_结合case_class发送消息&#34;&gt;1.2.4. 第四个例子（结合case class发送消息）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_练习&#34;&gt;1.3. 练习&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_scala_actor编程&#34;&gt;1. Scala Actor编程&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_什么是scala_actor&#34;&gt;1.1. 什么是Scala Actor&lt;/h3&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_概念&#34;&gt;1.1.1. 概念&lt;/h4&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Scala中的Actor能够实现并行编程的强大功能，它是基于事件模型的并发机制，Scala是运用消息（message）的发送、接收来实现多线程的。使用Scala能够更容易地实现多线程应用的开发。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_传统java并发编程与scala_actor编程的区别&#34;&gt;1.1.2. 传统java并发编程与Scala Actor编程的区别&lt;/h4&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/img/scala/2017-04-05_095545.png&#34; alt=&#34;2017 04 05 095545&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;对于Java，我们都知道它的多线程实现需要对共享资源（变量、对象等）使用synchronized 关键字进行代码块同步、对象锁互斥等等。而且，常常一大块的try…catch语句块中加上wait方法、notify方法、notifyAll方法是让人很头疼的。原因就在于Java中多数使用的是可变状态的对象资源，对这些资源进行共享来实现多线程编程的话，控制好资源竞争与防止对象状态被意外修改是非常重要的，而对象状态的不变性也是较难以保证的。 而在Scala中，我们可以通过复制不可变状态的资源（即对象，Scala中一切都是对象，连函数、方法也是）的一个副本，再基于Actor的消息发送、接收机制进行并行编程&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_actor方法执行顺序&#34;&gt;1.1.3. Actor方法执行顺序&lt;/h4&gt;
&lt;div class=&#34;olist arabic&#34;&gt;
&lt;ol class=&#34;arabic&#34;&gt;
&lt;li&gt;
&lt;p&gt;首先调用start()方法启动Actor&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用start()方法后其act()方法会被执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;向Actor发送消息&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_发送消息的方式&#34;&gt;1.1.4. 发送消息的方式&lt;/h4&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;!
发送异步消息，没有返回值。
!?
发送同步消息，等待返回值。
!!
发送异步消息，返回值是 Future[Any]。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_actor实战&#34;&gt;1.2. Actor实战&lt;/h3&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_第一个例子&#34;&gt;1.2.1. 第一个例子&lt;/h4&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;object MyActor1 extends Actor{
  //重新act方法
  def act(){
    for(i &amp;lt;- 1 to 10){
      println(&#34;actor-1 &#34;+ i)
      Thread.sleep(2000)
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;object MyActor2 extends Actor{
  //重新act方法
  def act(){
    for(i &amp;lt;- 1 to 10){
      println(&#34;actor-2 &#34;+ i)
      Thread.sleep(2000)
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;object ActorTest extends App{
  //启动Actor
  MyActor1.start()
  MyActor2.start()
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;说明：上面分别调用了两个单例对象的start()方法，他们的act()方法会被执行，相同与在java中开启了两个线程，线程的run()方法会被执行
注意：这两个Actor是并行执行的，act()方法中的for循环执行完成后actor程序就退出了&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_第二个例子_可以不断地接收消息&#34;&gt;1.2.2. 第二个例子（可以不断地接收消息）&lt;/h4&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;class MyActor extends Actor {

  override def act(): Unit = {
    while (true) {
      receive {
        case &#34;start&#34;=&amp;gt; {
          println(&#34;starting ...&#34;)
          Thread.sleep(5000)
          println(&#34;started&#34;)
        }
        case &#34;stop&#34;=&amp;gt; {
          println(&#34;stopping ...&#34;)
          Thread.sleep(5000)
          println(&#34;stopped ...&#34;)
        }
      }
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;object MyActor {
  def main(args: Array[String]) {
    val actor = new MyActor
    actor.start()
    actor ! &#34;start&#34;
    actor ! &#34;stop&#34;
    println(&#34;消息发送完成！&#34;)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;说明：在act()方法中加入了while (true) 循环，就可以不停的接收消息
注意：发送start消息和stop的消息是异步的，但是Actor接收到消息执行的过程是同步的按顺序执行&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_第三个例子_react方式会复用线程_比receive更高效&#34;&gt;1.2.3. 第三个例子（react方式会复用线程，比receive更高效）&lt;/h4&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;class YourActor extends Actor {

  override def act(): Unit = {
    loop {
      react {
        case &#34;start&#34;=&amp;gt; {
          println(&#34;starting ...&#34;)
          Thread.sleep(5000)
          println(&#34;started&#34;)
        }
        case &#34;stop&#34;=&amp;gt; {
          println(&#34;stopping ...&#34;)
          Thread.sleep(8000)
          println(&#34;stopped ...&#34;)
        }
      }
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;object YourActor {
  def main(args: Array[String]) {
    val actor = new YourActor
    actor.start()
    actor ! &#34;start&#34;
    actor ! &#34;stop&#34;
    println(&#34;消息发送完成！&#34;)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;说明：?react 如果要反复执行消息处理，react外层要用loop，不能用while&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_第四个例子_结合case_class发送消息&#34;&gt;1.2.4. 第四个例子（结合case class发送消息）&lt;/h4&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;class AppleActor extends Actor {

  def act(): Unit = {
    while (true) {
      receive {
        case &#34;start&#34;=&amp;gt;println(&#34;starting ...&#34;)
        case SyncMsg(id, msg) =&amp;gt; {
          println(id + &#34;,sync &#34;+ msg)
          Thread.sleep(5000)
          sender ! ReplyMsg(3,&#34;finished&#34;)
        }
        case AsyncMsg(id, msg) =&amp;gt; {
          println(id + &#34;,async &#34;+ msg)
          Thread.sleep(5000)
        }
      }
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;object AppleActor {
  def main(args: Array[String]) {
    val a = new AppleActor
    a.start()
    //异步消息
    a ! AsyncMsg(1, &#34;hello actor&#34;)
    println(&#34;异步消息发送完成&#34;)
    //同步消息
    //val content = a.!?(1000, SyncMsg(2, &#34;hello actor&#34;))
    //println(content)
    val reply = a !! SyncMsg(2, &#34;hello actor&#34;)
    println(reply.isSet)
    //println(&#34;123&#34;)
    val c = reply.apply()
    println(reply.isSet)
    println(c)
  }
}
case class SyncMsg(id : Int, msg: String)
case class AsyncMsg(id : Int, msg: String)
case class ReplyMsg(id : Int, msg: String)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_练习&#34;&gt;1.3. 练习&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;用actor并发编程写一个单机版的WorldCount，将多个文件作为输入，计算完成后将多个任务汇总，得到最终的结果&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;class Task extends Actor {

  override def act(): Unit = {
    loop {
      react {
        case SubmitTask(fileName) =&amp;gt; {
          val contents = Source.fromFile(new File(fileName)).mkString
          val arr = contents.split(&#34;\r\n&#34;)
          val result = arr.flatMap(_.split(&#34;&#34;)).map((_, 1)).groupBy(_._1).mapValues(_.length)
          //val result = arr.flatMap(_.split(&#34;&#34;)).map((_, 1)).groupBy(_._1).mapValues(_.foldLeft(0)(_ + _._2))
          sender ! ResultTask(result)
        }
        case StopTask =&amp;gt; {
          exit()
        }
      }
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;object WorkCount {
  def main(args: Array[String]) {
    val files = Array(&#34;c://words.txt&#34;, &#34;c://words.log&#34;)

    val replaySet = new mutable.HashSet[Future[Any]]
    val resultList = new mutable.ListBuffer[ResultTask]

    for(f &amp;lt;- files) {
      val t = new Task
      val replay = t.start() !! SubmitTask(f)
      replaySet += replay
    }

    while(replaySet.size &amp;gt;0){
      val toCumpute = replaySet.filter(_.isSet)
      for(r &amp;lt;- toCumpute){
        val result = r.apply()
        resultList += result.asInstanceOf[ResultTask]
        replaySet.remove(r)
      }
      Thread.sleep(100)
    }
    val finalResult = resultList.map(_.result).flatten.groupBy(_._1).mapValues(x =&amp;gt; x.foldLeft(0)(_ + _._2))
    println(finalResult)
  }
}

case class SubmitTask(fileName: String)
case object StopTask
case class ResultTask(result: Map[String, Int])&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>scala基础</title>
      <link>/post/bigdata/scala/scala%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 04 Apr 2017 15:25:28 +0000</pubDate>
      
      <guid>/post/bigdata/scala/scala%E5%9F%BA%E7%A1%80/</guid>
      <description>&lt;div id=&#34;toc&#34; class=&#34;toc&#34;&gt;
&lt;div id=&#34;toctitle&#34;&gt;scala基础&lt;/div&gt;
&lt;ul class=&#34;sectlevel1&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_scala基础&#34;&gt;1. Scala基础&lt;/a&gt;
&lt;ul class=&#34;sectlevel2&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_声明变量&#34;&gt;1.1. 声明变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_常用类型&#34;&gt;1.2. 常用类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_条件表达式&#34;&gt;1.3. 条件表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_块表达式&#34;&gt;1.4. 块表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_循环&#34;&gt;1.5. 循环&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_调用方法和函数&#34;&gt;1.6. 调用方法和函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_定义方法和函数&#34;&gt;1.7. 定义方法和函数&lt;/a&gt;
&lt;ul class=&#34;sectlevel3&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_定义方法&#34;&gt;1.7.1. 定义方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_定义函数&#34;&gt;1.7.2. 定义函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_方法和函数的区别&#34;&gt;1.7.3. 方法和函数的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_将方法转换成函数_神奇的下划线&#34;&gt;1.7.4. 将方法转换成函数（神奇的下划线）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_数组_映射_元组_集合&#34;&gt;2. 数组、映射、元组、集合&lt;/a&gt;
&lt;ul class=&#34;sectlevel2&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_数组&#34;&gt;2.1. 数组&lt;/a&gt;
&lt;ul class=&#34;sectlevel3&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_定长数组和变长数组&#34;&gt;2.1.1. 定长数组和变长数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_遍历数组&#34;&gt;2.1.2. 遍历数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_数组转换&#34;&gt;2.1.3. 数组转换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_数组常用算法&#34;&gt;2.1.4. 数组常用算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_映射&#34;&gt;2.2. 映射&lt;/a&gt;
&lt;ul class=&#34;sectlevel3&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_构建映射&#34;&gt;2.2.1. 构建映射&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_获取和修改映射中的值&#34;&gt;2.2.2. 获取和修改映射中的值&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_元组&#34;&gt;2.3. 元组&lt;/a&gt;
&lt;ul class=&#34;sectlevel3&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_创建元组&#34;&gt;2.3.1. 创建元组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_获取元组中的值&#34;&gt;2.3.2. 获取元组中的值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_将对偶的集合转换成映射&#34;&gt;2.3.3. 将对偶的集合转换成映射&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_拉链操作&#34;&gt;2.3.4. 拉链操作&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_集合&#34;&gt;2.4. 集合&lt;/a&gt;
&lt;ul class=&#34;sectlevel3&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_序列&#34;&gt;2.4.1. 序列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_set&#34;&gt;2.5. Set&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_map&#34;&gt;2.6. Map&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_类_对象_继承_特质&#34;&gt;3. 类、对象、继承、特质&lt;/a&gt;
&lt;ul class=&#34;sectlevel2&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_类&#34;&gt;3.1. 类&lt;/a&gt;
&lt;ul class=&#34;sectlevel3&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_类的定义&#34;&gt;3.1.1. 类的定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_构造器&#34;&gt;3.1.2. 构造器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_对象&#34;&gt;3.2. 对象&lt;/a&gt;
&lt;ul class=&#34;sectlevel3&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_单例对象&#34;&gt;3.2.1. 单例对象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_伴生对象&#34;&gt;3.2.2. 伴生对象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_apply方法&#34;&gt;3.2.3. apply方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_应用程序对象&#34;&gt;3.2.4. 应用程序对象&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_继承&#34;&gt;3.3. 继承&lt;/a&gt;
&lt;ul class=&#34;sectlevel3&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_扩展类&#34;&gt;3.3.1. 扩展类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_重写方法&#34;&gt;3.3.2. 重写方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_类型检查和转换&#34;&gt;3.3.3. 类型检查和转换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_超类的构造&#34;&gt;3.3.4. 超类的构造&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_模式匹配和样例类&#34;&gt;4. 模式匹配和样例类&lt;/a&gt;
&lt;ul class=&#34;sectlevel2&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#_匹配字符串&#34;&gt;4.1. 匹配字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_匹配类型&#34;&gt;4.2. 匹配类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_匹配数组_元组&#34;&gt;4.3. 匹配数组、元组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_样例类&#34;&gt;4.4. 样例类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_option类型&#34;&gt;4.5. Option类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_偏函数&#34;&gt;4.6. 偏函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#_单机版_wordcount&#34;&gt;5. 单机版 wordcount&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_scala基础&#34;&gt;1. Scala基础&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_声明变量&#34;&gt;1.1. 声明变量&lt;/h3&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;object VariableDemo {
  def main(args: Array[String]) {
    //使用val定义的变量值是不可变的，相当于java里用final修饰的变量
    val i = 1
    //使用var定义的变量是可变得，在Scala中鼓励使用val
    var s = &#34;hello&#34;
    //Scala编译器会自动推断变量的类型，必要的时候可以指定类型
    //变量名在前，类型在后
    val str: String = &#34;itcast&#34;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_常用类型&#34;&gt;1.2. 常用类型&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;Scala&lt;/strong&gt; 和 &lt;strong&gt;Java&lt;/strong&gt; 一样，有7种数值类型 &lt;strong&gt;Byte&lt;/strong&gt; 、 &lt;strong&gt;Char&lt;/strong&gt; 、 &lt;strong&gt;Short&lt;/strong&gt; 、 &lt;strong&gt;Int&lt;/strong&gt; 、 &lt;strong&gt;Long&lt;/strong&gt; 、 &lt;strong&gt;Float&lt;/strong&gt; 和 &lt;strong&gt;Double&lt;/strong&gt; （无包装类型）和一个 &lt;strong&gt;Boolean&lt;/strong&gt; 类型&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_条件表达式&#34;&gt;1.3. 条件表达式&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Scala的的条件表达式比较简洁，例如：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;object ConditionDemo {
  def main(args: Array[String]) {
    val x = 1
    //判断x的值，将结果赋给y
    val y = if (x &amp;gt; 0) 1 else -1
    //打印y的值
    println(y)

    //支持混合类型表达式
    val z = if (x &amp;gt; 1) 1 else &#34;error&#34;
    //打印z的值
    println(z)

    //如果缺失else，相当于if (x &amp;gt; 2) 1 else ()
    val m = if (x &amp;gt; 2) 1
    println(m)

    //在scala中每个表达式都有值，scala中有个Unit类，写做(),相当于Java中的void
    val n = if (x &amp;gt; 2) 1 else ()
    println(n)

    //if和else if
    val k = if (x &amp;lt; 0) 0
    else if (x &amp;gt;= 1) 1 else -1
    println(k)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_块表达式&#34;&gt;1.4. 块表达式&lt;/h3&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;object BlockExpressionDemo {
  def main(args: Array[String]) {
    val x = 0
    //在scala中{}中课包含一系列表达式，块中最后一个表达式的值就是块的值
    //下面就是一个块表达式
    val result = {
      if (x &amp;lt; 0){
        -1
      } else if(x &amp;gt;= 1) {
        1
      } else {
        &#34;error&#34;
      }
    }
    //result的值就是块表达式的结果
    println(result)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_循环&#34;&gt;1.5. 循环&lt;/h3&gt;
&lt;div class=&#34;quoteblock&#34;&gt;
&lt;blockquote&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;在scala中有for循环和while循环，用for循环比较多
for循环语法结构：for (i &amp;#8592; 表达式/数组/集合)&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;object ForDemo {
  def main(args: Array[String]) {
    //for(i &amp;lt;- 表达式),表达式1 to 10返回一个Range（区间）
    //每次循环将区间中的一个值赋给i
    for (i &amp;lt;- 1 to 10)
      println(i)

    //for(i &amp;lt;- 数组)
    val arr = Array(&#34;a&#34;, &#34;b&#34;, &#34;c&#34;)
    for (i &amp;lt;- arr)
      println(i)

    //高级for循环
    //每个生成器都可以带一个条件，注意：if前面没有分号
    for(i &amp;lt;- 1 to 3; j &amp;lt;- 1 to 3 if i != j)
      print((10 * i + j) + &#34; &#34;)
    println()

    //for推导式：如果for循环的循环体以yield开始，则该循环会构建出一个集合
    //每次迭代生成集合中的一个值
    val v = for (i &amp;lt;- 1 to 10) yield i * 10
    println(v)

  }

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_调用方法和函数&#34;&gt;1.6. 调用方法和函数&lt;/h3&gt;
&lt;div class=&#34;quoteblock&#34;&gt;
&lt;blockquote&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Scala中的+ - * / %等操作符的作用与Java一样，位操作符 &amp;amp; | ^ &amp;gt;&amp;gt; &amp;lt;&amp;lt;也一样。只是有
一点特别的：这些操作符实际上是方法。&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;例如：
　　a + b
是如下方法调用的简写：
　　a. +(b)
a 方法 b可以写成 a.方法(b)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_定义方法和函数&#34;&gt;1.7. 定义方法和函数&lt;/h3&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_定义方法&#34;&gt;1.7.1. 定义方法&lt;/h4&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/img/scala/2017-04-04_162650.png&#34; alt=&#34;2017 04 04 162650&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;方法的返回值类型可以不写，编译器可以自动推断出来，但是对于递归函数，必须指定返回类型&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_定义函数&#34;&gt;1.7.2. 定义函数&lt;/h4&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/img/scala/2017-04-04_162701.png&#34; alt=&#34;2017 04 04 162701&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_方法和函数的区别&#34;&gt;1.7.3. 方法和函数的区别&lt;/h4&gt;
&lt;div class=&#34;quoteblock&#34;&gt;
&lt;blockquote&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;在函数式编程语言中，函数是“头等公民”，它可以像任何其他数据类型一样被传递和操作&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;+
image::/src/img/scala/2017-04-04_162709.png[]
---
案例：首先定义一个方法，再定义一个函数，然后将函数传递到方法里面&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;object MethodAndFunctionDemo {
  //定义一个方法
  //方法m2参数要求是一个函数，函数的参数必须是两个Int类型
  //返回值类型也是Int类型
  def m1(f: (Int, Int) =&amp;gt; Int) : Int = {
    f(2, 6)
  }

  //定义一个函数f1，参数是两个Int类型，返回值是一个Int类型
  val f1 = (x: Int, y: Int) =&amp;gt; x + y
  //再定义一个函数f2
  val f2 = (m: Int, n: Int) =&amp;gt; m * n

  //main方法
  def main(args: Array[String]) {

    //调用m1方法，并传入f1函数
    val r1 = m1(f1)
    println(r1)

    //调用m1方法，并传入f2函数
    val r2 = m1(f2)
    println(r2)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_将方法转换成函数_神奇的下划线&#34;&gt;1.7.4. 将方法转换成函数（神奇的下划线）&lt;/h4&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/img/scala/2017-04-04_162717.png&#34; alt=&#34;2017 04 04 162717&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_数组_映射_元组_集合&#34;&gt;2. 数组、映射、元组、集合&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_数组&#34;&gt;2.1. 数组&lt;/h3&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_定长数组和变长数组&#34;&gt;2.1.1. 定长数组和变长数组&lt;/h4&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;import scala.collection.mutable.ArrayBuffer
object ArrayDemo {

  def main(args: Array[String]) {

    //初始化一个长度为8的定长数组，其所有元素均为0
    val arr1 = new Array[Int](8)
    //直接打印定长数组，内容为数组的hashcode值
    println(arr1)
    //将数组转换成数组缓冲，就可以看到原数组中的内容了
    //toBuffer会将数组转换长数组缓冲
    println(arr1.toBuffer)

    //注意：如果new，相当于调用了数组的apply方法，直接为数组赋值
    //初始化一个长度为1的定长数组
    val arr2 = Array[Int](10)
    println(arr2.toBuffer)

    //定义一个长度为3的定长数组
    val arr3 = Array(&#34;hadoop&#34;, &#34;storm&#34;, &#34;spark&#34;)
    //使用()来访问元素
    println(arr3(2))

    //////////////////////////////////////////////////
    //变长数组（数组缓冲）
    //如果想使用数组缓冲，需要导入import scala.collection.mutable.ArrayBuffer包
    val ab = ArrayBuffer[Int]()
    //向数组缓冲的尾部追加一个元素
    //+=尾部追加元素
    ab += 1
    //追加多个元素
    ab += (2, 3, 4, 5)
    //追加一个数组++=
    ab ++= Array(6, 7)
    //追加一个数组缓冲
    ab ++= ArrayBuffer(8,9)
    //打印数组缓冲ab

    //在数组某个位置插入元素用insert
    ab.insert(0, -1, 0)
    //删除数组某个位置的元素用remove
    ab.remove(8, 2)
    println(ab)

  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_遍历数组&#34;&gt;2.1.2. 遍历数组&lt;/h4&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;1.增强for循环
2.好用的until会生成脚标，0 until 10 包含0不包含10&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/img/scala/2017-04-04_162727.png&#34; alt=&#34;2017 04 04 162727&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;object ForArrayDemo {

  def main(args: Array[String]) {
    //初始化一个数组
    val arr = Array(1,2,3,4,5,6,7,8)
    //增强for循环
    for(i &amp;lt;- arr)
      println(i)

    //好用的until会生成一个Range
    //reverse是将前面生成的Range反转
    for(i &amp;lt;- (0 until arr.length).reverse)
      println(arr(i))
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_数组转换&#34;&gt;2.1.3. 数组转换&lt;/h4&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;yield关键字将原始的数组进行转换会产生一个新的数组，原始的数组不变&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/img/scala/2017-04-04_162736.png&#34; alt=&#34;2017 04 04 162736&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;object ArrayYieldDemo {
  def main(args: Array[String]) {
    //定义一个数组
    val arr = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)
    //将偶数取出乘以10后再生成一个新的数组
    val res = for (e &amp;lt;- arr if e % 2 == 0) yield e * 10
    println(res.toBuffer)

    //更高级的写法,用着更爽
    //filter是过滤，接收一个返回值为boolean的函数
    //map相当于将数组中的每一个元素取出来，应用传进去的函数
    val r = arr.filter(_ % 2 == 0).map(_ * 10)
    println(r.toBuffer)

  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_数组常用算法&#34;&gt;2.1.4. 数组常用算法&lt;/h4&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;在Scala中，数组上的某些方法对数组进行相应的操作非常方便！&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/img/scala/2017-04-04_162743.png&#34; alt=&#34;2017 04 04 162743&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_映射&#34;&gt;2.2. 映射&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;在Scala中，把哈希表这种数据结构叫做映射&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_构建映射&#34;&gt;2.2.1. 构建映射&lt;/h4&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/img/scala/2017-04-04_162749.png&#34; alt=&#34;2017 04 04 162749&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_获取和修改映射中的值&#34;&gt;2.2.2. 获取和修改映射中的值&lt;/h4&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/img/scala/2017-04-04_162755.png&#34; alt=&#34;2017 04 04 162755&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;好用的getOrElse&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/img/scala/2017-04-04_162802.png&#34; alt=&#34;2017 04 04 162802&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;注意：在Scala中，有两种Map，一个是immutable包下的Map，该Map中的内容不可变；另一个是mutable包下的Map，该Map中的内容可变
例子：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/img/scala/2017-04-04_162812.png&#34; alt=&#34;2017 04 04 162812&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;注意：通常我们在创建一个集合是会用val这个关键字修饰一个变量（相当于java中的final），那么就意味着该变量的引用不可变，该引用中的内容是不是可变，取决于这个引用指向的集合的类型&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_元组&#34;&gt;2.3. 元组&lt;/h3&gt;
&lt;div class=&#34;quoteblock&#34;&gt;
&lt;blockquote&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;映射是K/V对偶的集合，对偶是元组的最简单形式，元组可以装着多个不同类型的值。&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_创建元组&#34;&gt;2.3.1. 创建元组&lt;/h4&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/img/scala/2017-04-04_162819.png&#34; alt=&#34;2017 04 04 162819&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_获取元组中的值&#34;&gt;2.3.2. 获取元组中的值&lt;/h4&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/img/scala/2017-04-04_162828.png&#34; alt=&#34;2017 04 04 162828&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_将对偶的集合转换成映射&#34;&gt;2.3.3. 将对偶的集合转换成映射&lt;/h4&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/img/scala/2017-04-04_162835.png&#34; alt=&#34;2017 04 04 162835&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_拉链操作&#34;&gt;2.3.4. 拉链操作&lt;/h4&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;zip命令可以将多个值绑定在一起&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;/src/img/scala/2017-04-04_162841.png&#34; alt=&#34;2017 04 04 162841&#34;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;注意：如果两个数组的元素个数不一致，拉链操作后生成的数组的长度为较小的那个数组的元素个数&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_集合&#34;&gt;2.4. 集合&lt;/h3&gt;
&lt;div class=&#34;dlist&#34;&gt;
&lt;dl&gt;
&lt;dt class=&#34;hdlist1&#34;&gt;Scala的集合有三大类&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;序列Seq、集Set、映射Map，所有的集合都扩展自Iterable特质
在Scala中集合有可变（mutable）和不可变（immutable）两种类型，immutable类型的集合初始化后就不能改变了（注意与val修饰的变量进行区别）&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_序列&#34;&gt;2.4.1. 序列&lt;/h4&gt;
&lt;div class=&#34;dlist&#34;&gt;
&lt;dl&gt;
&lt;dt class=&#34;hdlist1&#34;&gt;不可变的序列 &lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;&lt;code&gt;import scala.collection.immutable._&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;在Scala中列表要么为空（Nil表示空列表）要么是一个head元素加上一个tail列表。
9 :: List(5, 2)  :: 操作符是将给定的头和尾创建一个新的列表
注意：:: 操作符是右结合的，如9 :: 5 :: 2 :: Nil相当于 9 :: (5 :: (2 :: Nil))&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;object ImmutListDemo {

  def main(args: Array[String]) {
    //创建一个不可变的集合
    val lst1 = List(1,2,3)
    //将0插入到lst1的前面生成一个新的List
    val lst2 = 0 :: lst1
    val lst3 = lst1.::(0)
    val lst4 = 0 +: lst1
    val lst5 = lst1.+:(0)

    //将一个元素添加到lst1的后面产生一个新的集合
    val lst6 = lst1 :+ 3

    val lst0 = List(4,5,6)
    //将2个list合并成一个新的List
    val lst7 = lst1 ++ lst0
    //将lst1插入到lst0前面生成一个新的集合
    val lst8 = lst1 ++: lst0

    //将lst0插入到lst1前面生成一个新的集合
    val lst9 = lst1.:::(lst0)

    println(lst9)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;dlist&#34;&gt;
&lt;dl&gt;
&lt;dt class=&#34;hdlist1&#34;&gt;可变的序列 &lt;code&gt;import scala.collection.mutable._&lt;/code&gt; &lt;/dt&gt;
&lt;dd&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;import scala.collection.mutable.ListBuffer

object MutListDemo extends App{
  //构建一个可变列表，初始有3个元素1,2,3
  val lst0 = ListBuffer[Int](1,2,3)
  //创建一个空的可变列表
  val lst1 = new ListBuffer[Int]
  //向lst1中追加元素，注意：没有生成新的集合
  lst1 += 4
  lst1.append(5)

  //将lst1中的元素最近到lst0中， 注意：没有生成新的集合
  lst0 ++= lst1

  //将lst0和lst1合并成一个新的ListBuffer 注意：生成了一个集合
  val lst2= lst0 ++ lst1

  //将元素追加到lst0的后面生成一个新的集合
  val lst3 = lst0 :+ 5
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_set&#34;&gt;2.5. Set&lt;/h3&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;不可变的Set&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;import scala.collection.immutable.HashSet

object ImmutSetDemo extends App{
  val set1 = new HashSet[Int]()
  //将元素和set1合并生成一个新的set，原有set不变
  val set2 = set1 + 4
  //set中元素不能重复
  val set3 = set1 ++ Set(5, 6, 7)
  val set0 = Set(1,3,4) ++ set1
  println(set0.getClass)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;可变的Set&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;import scala.collection.mutable

object MutSetDemo extends App{
  //创建一个可变的HashSet
  val set1 = new mutable.HashSet[Int]()
  //向HashSet中添加元素
  set1 += 2
  //add等价于+=
  set1.add(4)
  set1 ++= Set(1,3,5)
  println(set1)
  //删除一个元素
  set1 -= 5
  set1.remove(2)
  println(set1)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_map&#34;&gt;2.6. Map&lt;/h3&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;import scala.collection.mutable

object MutMapDemo extends App{
  val map1 = new mutable.HashMap[String, Int]()
  //向map中添加数据
  map1(&#34;spark&#34;) = 1
  map1 += ((&#34;hadoop&#34;, 2))
  map1.put(&#34;storm&#34;, 3)
  println(map1)

  //从map中移除元素
  map1 -= &#34;spark&#34;
  map1.remove(&#34;hadoop&#34;)
  println(map1)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_类_对象_继承_特质&#34;&gt;3. 类、对象、继承、特质&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;quoteblock&#34;&gt;
&lt;blockquote&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Scala的类与Java、C++的类比起来更简洁，学完之后你会更爱Scala！！！&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_类&#34;&gt;3.1. 类&lt;/h3&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_类的定义&#34;&gt;3.1.1. 类的定义&lt;/h4&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;//在Scala中，类并不用声明为public。
//Scala源文件中可以包含多个类，所有这些类都具有公有可见性。
class Person {
  //用val修饰的变量是只读属性，有getter但没有setter
  //（相当与Java中用final修饰的变量）
  val id = &#34;9527&#34;

  //用var修饰的变量既有getter又有setter
  var age: Int = 18

  //类私有字段,只能在类的内部使用
  private var name: String = &#34;唐伯虎&#34;

  //对象私有字段,访问权限更加严格的，Person类的方法只能访问到当前对象的字段
  private[this] val pet = &#34;小强&#34;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_构造器&#34;&gt;3.1.2. 构造器&lt;/h4&gt;
&lt;div class=&#34;admonitionblock important&#34;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&#34;icon&#34;&gt;
&lt;i class=&#34;fa icon-important&#34; title=&#34;Important&#34;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&#34;content&#34;&gt;
主构造器会执行类定义中的所有语句
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&#34;openblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;/**
  *每个类都有主构造器，主构造器的参数直接放置类名后面，与类交织在一起
  */
class Student(val name: String, val age: Int){
  //主构造器会执行类定义中的所有语句
  println(&#34;执行主构造器&#34;)

  try {
    println(&#34;读取文件&#34;)
    throw new IOException(&#34;io exception&#34;)
  } catch {
    case e: NullPointerException =&amp;gt; println(&#34;打印异常Exception : &#34; + e)
    case e: IOException =&amp;gt; println(&#34;打印异常Exception : &#34; + e)
  } finally {
    println(&#34;执行finally部分&#34;)
  }

  private var gender = &#34;male&#34;

  //用this关键字定义辅助构造器
  def this(name: String, age: Int, gender: String){
    //每个辅助构造器必须以主构造器或其他的辅助构造器的调用开始
    this(name, age)
    println(&#34;执行辅助构造器&#34;)
    this.gender = gender
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;/**
  *构造器参数可以不带val或var，如果不带val或var的参数至少被一个方法所使用，
  *那么它将会被提升为字段
  */
//在类名后面加private就变成了私有的
class Queen private(val name: String, prop: Array[String], private var age: Int = 18){

  println(prop.size)

  //prop被下面的方法使用后，prop就变成了不可变得对象私有字段，等同于private[this] val prop
  //如果没有被方法使用该参数将不被保存为字段，仅仅是一个可以被主构造器中的代码访问的普通参数
  def description = name + &#34; is &#34; + age + &#34; years old with &#34; + prop.toBuffer
}

object Queen{
  def main(args: Array[String]) {
    //私有的构造器，只有在其伴生对象中使用
    val q = new Queen(&#34;hatano&#34;, Array(&#34;蜡烛&#34;, &#34;皮鞭&#34;), 20)
    println(q.description())
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_对象&#34;&gt;3.2. 对象&lt;/h3&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_单例对象&#34;&gt;3.2.1. 单例对象&lt;/h4&gt;
&lt;div class=&#34;quoteblock&#34;&gt;
&lt;blockquote&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;在Scala中没有静态方法和静态字段，但是可以使用object这个语法结构来达到同样的目的&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&#34;olist arabic&#34;&gt;
&lt;ol class=&#34;arabic&#34;&gt;
&lt;li&gt;
&lt;p&gt;存放工具方法和常量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高效共享单个不可变的实例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单例模式&lt;/p&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;import scala.collection.mutable.ArrayBuffer

object SingletonDemo {
  def main(args: Array[String]) {
    //单例对象，不需要new，用【类名.方法】调用对象中的方法
    val session = SessionFactory.getSession()
    println(session)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;object SessionFactory{
  //该部分相当于java中的静态块
  var counts = 5
  val sessions = new ArrayBuffer[Session]()
  while(counts &amp;gt; 0){
    sessions += new Session
    counts -= 1
  }

  //在object中的方法相当于java中的静态方法
  def getSession(): Session ={
    sessions.remove(0)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;class Session{

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_伴生对象&#34;&gt;3.2.2. 伴生对象&lt;/h4&gt;
&lt;div class=&#34;quoteblock&#34;&gt;
&lt;blockquote&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;在Scala的类中，与类名相同的对象叫做伴生对象，类和伴生对象之间可以相互访问私有的方法和属性&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;class Dog {
  val id = 1
  private var name = &#34;itcast&#34;

  def printName(): Unit ={
    //在Dog类中可以访问伴生对象Dog的私有属性
    println(Dog.CONSTANT + name )
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;/**
  * 伴生对象
  */
object Dog {

  //伴生对象中的私有属性
  private val CONSTANT = &#34;汪汪汪 : &#34;

  def main(args: Array[String]) {
    val p = new Dog
    //访问私有的字段name
    p.name = &#34;123&#34;
    p.printName()
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_apply方法&#34;&gt;3.2.3. apply方法&lt;/h4&gt;
&lt;div class=&#34;quoteblock&#34;&gt;
&lt;blockquote&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;通常我们会在类的伴生对象中定义apply方法，当遇到类名(参数1,&amp;#8230;&amp;#8203;参数n)时apply方法会被调用&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;object ApplyDemo {
  def main(args: Array[String]) {
    //调用了Array伴生对象的apply方法
    //def apply(x: Int, xs: Int*): Array[Int]
    //arr1中只有一个元素5
    val arr1 = Array(5)
    println(arr1.toBuffer)

    //new了一个长度为5的array，数组里面包含5个null
    var arr2 = new Array(5)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_应用程序对象&#34;&gt;3.2.4. 应用程序对象&lt;/h4&gt;
&lt;div class=&#34;quoteblock&#34;&gt;
&lt;blockquote&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Scala程序都必须从一个对象的main方法开始，可以通过扩展App特质，不写main方法。&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;object AppObjectDemo extends App{
  //不用写main方法
  println(&#34;I love you Scala&#34;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_继承&#34;&gt;3.3. 继承&lt;/h3&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_扩展类&#34;&gt;3.3.1. 扩展类&lt;/h4&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;在Scala中扩展类的方式和Java一样都是使用extends关键字&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_重写方法&#34;&gt;3.3.2. 重写方法&lt;/h4&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;在Scala中重写一个非抽象的方法必须使用override修饰符&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_类型检查和转换&#34;&gt;3.3.3. 类型检查和转换&lt;/h4&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;Scala
Java
obj.isInstanceOf[C]
obj instanceof C
obj.asInstanceOf[C]
(C)obj
classOf[C]
C.class&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect3&#34;&gt;
&lt;h4 id=&#34;_超类的构造&#34;&gt;3.3.4. 超类的构造&lt;/h4&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;object ClazzDemo {
  def main(args: Array[String]) {
    //val h = new Human
    //println(h.fight)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;trait Flyable{
  def fly(): Unit ={
    println(&#34;I can fly&#34;)
  }

  def fight(): String
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;abstract class Animal {
  def run(): Int
  val name: String
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;class Human extends Animal with Flyable{

  val name = &#34;abc&#34;

  //打印几次&#34;ABC&#34;?
  val t1,t2,(a, b, c) = {
    println(&#34;ABC&#34;)
    (1,2,3)
  }

  println(a)
  println(t1._1)

  //在Scala中重写一个非抽象方法必须用override修饰
  override def fight(): String = {
    &#34;fight with 棒子&#34;
  }
  //在子类中重写超类的抽象方法时，不需要使用override关键字，写了也可以
  def run(): Int = {
    1
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_模式匹配和样例类&#34;&gt;4. 模式匹配和样例类&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Scala有一个十分强大的模式匹配机制，可以应用到很多场合：如switch语句、类型检查等。
并且Scala还提供了样例类，对模式匹配进行了优化，可以快速进行匹配&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_匹配字符串&#34;&gt;4.1. 匹配字符串&lt;/h3&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;import scala.util.Random

object CaseDemo01 extends App{
  val arr = Array(&#34;YoshizawaAkiho&#34;, &#34;YuiHatano&#34;, &#34;AoiSola&#34;)
  val name = arr(Random.nextInt(arr.length))
  name match {
    case &#34;YoshizawaAkiho&#34; =&amp;gt; println(&#34;吉泽老师...&#34;)
    case &#34;YuiHatano&#34; =&amp;gt; println(&#34;波多老师...&#34;)
    case _ =&amp;gt; println(&#34;真不知道你们在说什么...&#34;)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_匹配类型&#34;&gt;4.2. 匹配类型&lt;/h3&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;import scala.util.Random

object CaseDemo01 extends App{
  //val v = if(x &amp;gt;= 5) 1 else if(x &amp;lt; 2) 2.0 else &#34;hello&#34;
  val arr = Array(&#34;hello&#34;, 1, 2.0, CaseDemo)
  val v = arr(Random.nextInt(4))
  println(v)
  v match {
    case x: Int =&amp;gt; println(&#34;Int &#34; + x)
    case y: Double if(y &amp;gt;= 0) =&amp;gt; println(&#34;Double &#34;+ y)
    case z: String =&amp;gt; println(&#34;String &#34; + z)
    case _ =&amp;gt; throw new Exception(&#34;not match exception&#34;)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;注意：case y: Double if(y &amp;gt;= 0) &amp;#8658; &amp;#8230;&amp;#8203;
模式匹配的时候还可以添加守卫条件。如不符合守卫条件，将掉入case _中&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_匹配数组_元组&#34;&gt;4.3. 匹配数组、元组&lt;/h3&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;object CaseDemo03 extends App{

  val arr = Array(1, 3, 5)
  arr match {
    case Array(1, x, y) =&amp;gt; println(x + &#34; &#34; + y)
    case Array(0) =&amp;gt; println(&#34;only 0&#34;)
    case Array(0, _*) =&amp;gt; println(&#34;0 ...&#34;)
    case _ =&amp;gt; println(&#34;something else&#34;)
  }

  val lst = List(3, -1)
  lst match {
    case 0 :: Nil =&amp;gt; println(&#34;only 0&#34;)
    case x :: y :: Nil =&amp;gt; println(s&#34;x: $x y: $y&#34;)
    case 0 :: tail =&amp;gt; println(&#34;0 ...&#34;)
    case _ =&amp;gt; println(&#34;something else&#34;)
  }

  val tup = (2, 3, 7)
  tup match {
    case (1, x, y) =&amp;gt; println(s&#34;1, $x , $y&#34;)
    case (_, z, 5) =&amp;gt; println(z)
    case  _ =&amp;gt; println(&#34;else&#34;)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;openblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;div class=&#34;admonitionblock important&#34;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&#34;icon&#34;&gt;
&lt;i class=&#34;fa icon-important&#34; title=&#34;Important&#34;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&#34;content&#34;&gt;
在Scala中列表要么为空（Nil表示空列表）要么是一个head元素加上一个tail列表。&lt;br&gt;
9 :: List(5, 2)  :: 操作符是将给定的头和尾创建一个新的列表&lt;br&gt;
:: 操作符是右结合的，如9 :: 5 :: 2 :: Nil相当于 9 :: (5 :: (2 :: Nil))
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_样例类&#34;&gt;4.4. 样例类&lt;/h3&gt;
&lt;div class=&#34;quoteblock&#34;&gt;
&lt;blockquote&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;在Scala中样例类是一中特殊的类，可用于模式匹配。case class是多例的，后面要跟构造参数，case object是单例的&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;import scala.util.Random

case class SubmitTask(id: String, name: String)
case class HeartBeat(time: Long)
case object CheckTimeOutTask

object CaseDemo04 extends App{
  val arr = Array(CheckTimeOutTask, HeartBeat(12333), SubmitTask(&#34;0001&#34;, &#34;task-0001&#34;))

  arr(Random.nextInt(arr.length)) match {
    case SubmitTask(id, name) =&amp;gt; {
      println(s&#34;$id, $name&#34;)//前面需要加上s, $id直接取id的值
    }
    case HeartBeat(time) =&amp;gt; {
      println(time)
    }
    case CheckTimeOutTask =&amp;gt; {
      println(&#34;check&#34;)
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_option类型&#34;&gt;4.5. Option类型&lt;/h3&gt;
&lt;div class=&#34;quoteblock&#34;&gt;
&lt;blockquote&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;在Scala中Option类型样例类用来表示可能存在或也可能不存在的值(Option的子类有Some和None)。Some包装了某个值，None表示没有值&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;object OptionDemo {
  def main(args: Array[String]) {
    val map = Map(&#34;a&#34; -&amp;gt; 1, &#34;b&#34; -&amp;gt; 2)
    val v = map.get(&#34;b&#34;) match {
      case Some(i) =&amp;gt; i
      case None =&amp;gt; 0
    }
    println(v)
    //更好的方式
    val v1 = map.getOrElse(&#34;c&#34;, 0)
    println(v1)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_偏函数&#34;&gt;4.6. 偏函数&lt;/h3&gt;
&lt;div class=&#34;quoteblock&#34;&gt;
&lt;blockquote&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;被包在花括号内没有match的一组case语句是一个偏函数，它是PartialFunction[A, B]的一个实例，A代表参数类型，B代表返回类型，常用作输入模式匹配&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;object PartialFuncDemo  {

  def func1: PartialFunction[String, Int] = {
    case &#34;one&#34; =&amp;gt; 1
    case &#34;two&#34; =&amp;gt; 2
    case _ =&amp;gt; -1
  }

  def func2(num: String) : Int = num match {
    case &#34;one&#34; =&amp;gt; 1
    case &#34;two&#34; =&amp;gt; 2
    case _ =&amp;gt; -1
  }

  def main(args: Array[String]) {
    println(func1(&#34;one&#34;))
    println(func2(&#34;one&#34;))
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_单机版_wordcount&#34;&gt;5. 单机版 wordcount&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt;val lines = List(&#34;hello tom hello jerry&#34;,&#34;hello tom kitty hello hello&#34;)

lines.flatMap(_.split(&#34; &#34;)) &lt;i class=&#34;conum&#34; data-value=&#34;1&#34;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
    .map((_,1)) &lt;i class=&#34;conum&#34; data-value=&#34;2&#34;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
    .groupBy(_._1) &lt;i class=&#34;conum&#34; data-value=&#34;3&#34;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
    .map(t =&amp;gt; (t._1,t._2.size)) &lt;i class=&#34;conum&#34; data-value=&#34;4&#34;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
    .toList.sortBy(_._2) &lt;i class=&#34;conum&#34; data-value=&#34;5&#34;&gt;&lt;/i&gt;&lt;b&gt;(5)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;colist arabic&#34;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&#34;conum&#34; data-value=&#34;1&#34;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;res2: List[String] = List(hello, tom, hello, jerry, hello, tom, kitty, hello, hello)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&#34;conum&#34; data-value=&#34;2&#34;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;res4: List[(String, Int)] = Listhello,1), (tom,1), (hello,1), (jerry,1), (hello,1), (tom,1), (kitty,1), (hello,1), (hello,1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&#34;conum&#34; data-value=&#34;3&#34;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;res5: scala.collection.immutable.Map[String,List[(String, Int)]] = Map(tom &amp;#8594; Listtom,1), (tom,1, kitty &amp;#8594; Listkitty,1, jerry &amp;#8594; Listjerry,1, hello &amp;#8594; Listhello,1), (hello,1), (hello,1), (hello,1), (hello,1)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&#34;conum&#34; data-value=&#34;4&#34;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;res6: scala.collection.immutable.Map[String,Int] = Map(tom &amp;#8594; 2, kitty &amp;#8594; 1, jerry &amp;#8594; 1, hello &amp;#8594; 5)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&#34;conum&#34; data-value=&#34;5&#34;&gt;&lt;/i&gt;&lt;b&gt;5&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;res7: List[(String, Int)] = Listkitty,1), (jerry,1), (tom,2), (hello,5&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlightjs highlight&#34;&gt;&lt;code&gt; lines.flatMap(_.split(&#34; &#34;)).map((_,1)).groupBy(_._1).mapValues(_.foldLeft(0)(_+_._2))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>