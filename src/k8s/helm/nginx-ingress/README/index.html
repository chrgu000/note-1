<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title></title>
<meta name="description" content=" John Doe&#39;s Personal blog about everything">
<meta name="generator" content="Hugo 0.17" />
<meta property="og:title" content="" />
<meta property="og:description" content="nginx-ingress nginx-ingress is an Ingress controller that uses ConfigMap to store the nginx configuration.
To use, add the kubernetes.io/ingress.class: nginx annotation to your Ingress resources.
TL;DR; $ helm install stable/nginx-ingress  Introduction This chart bootstraps an nginx-ingress deployment on a Kubernetes cluster using the Helm package manager.
Prerequisites  Kubernetes 1.6&#43;  Installing the Chart To install the chart with the release name my-release:
$ helm install --name my-release stable/nginx-ingress  The command deploys nginx-ingress on the Kubernetes cluster in the default configuration." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/src/k8s/helm/nginx-ingress/README/" />














<link rel="stylesheet" href="/css/google-font.css?family=Open+Sans:400,400italic,700,600" type="text/css" media="all" />

<link rel="stylesheet" href="/css/railscasts.css">
<link rel="stylesheet" href="/css/style.css" type="text/css" media="all" />
<link rel="stylesheet" href="/css/custom.css" type="text/css" media="all" />
<link rel="stylesheet" href="/css/jquery.bigautocomplete.css" type="text/css" media="all" />
<link rel="stylesheet" href="/css/asciinema-player.css" type="text/css" media="all" />
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/fonts/fontawesome-webfont.svg" rel="stylesheet">

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script type="text/javascript" src="/js/scripts.js"></script>
<!--[if lt IE 9]>
	<script src="/js/css3-mediaqueries.js"></script>
<![endif]-->

</head>
<body id="mr-mobile" class="home blog mr-right-sb" itemscope="itemscope" itemtype="http://schema.org/WebPage">
	<div class="mr-container mr-container-outer">
		<div class="mr-header-mobile-nav clearfix"></div>
			<header class="mr-header" itemscope="itemscope" itemtype="http://schema.org/WPHeader">
				<div class="mr-container mr-container-inner mr-row clearfix">
					<div class="mr-custom-header clearfix">
						<div class="mr-site-identity">
							<div class="mr-site-logo" role="banner" itemscope="itemscope" itemtype="http://schema.org/Brand">
								<div class="mr-header-text">
									<a class="mr-header-text-link" href="/" title="零零碎碎" rel="home">
										<h1 class="mr-header-title">零零碎碎</h1>
										<h2 class="mr-header-tagline">点滴记录</h2>
									</a>
								</div>
							</div>
						</div>
					</div>
				</div>
				<div class="mr-main-nav-wrap">
					<nav class="menu" itemscope="itemscope" itemtype="http://schema.org/SiteNavigationElement">
	<ul class="menu__list">
        
            <li class="menu__item"><a class="menu__link" href="/categories/docker">docker</a></li>
        
            <li class="menu__item"><a class="menu__link" href="/categories/hadoop">hadoop</a></li>
        
            <li class="menu__item"><a class="menu__link" href="/categories/scala">scala</a></li>
        
            <li class="menu__item"><a class="menu__link" href="/categories/spark">spark</a></li>
        
	</ul>
</nav>
				</div>
			</header>
		<div class="mr-wrapper clearfix">


<div class="mr-content" id="main-content" role="main" itemprop="mainContentOfPage">
	<article class="post">
		<header class="entry-header clearfix">
			<h1 class="entry-title"></h1>
			<p class="mr-meta entry-meta">
				<svg class="icon icon-time" height="14" viewBox="0 0 16 16" width="14" xmlns="http://www.w3.org/2000/svg"><path d="m8-.0000003c-4.4 0-8 3.6-8 8 0 4.4000003 3.6 8.0000003 8 8.0000003 4.4 0 8-3.6 8-8.0000003 0-4.4-3.6-8-8-8zm0 14.4000003c-3.52 0-6.4-2.88-6.4-6.4000003 0-3.52 2.88-6.4 6.4-6.4 3.52 0 6.4 2.88 6.4 6.4 0 3.5200003-2.88 6.4000003-6.4 6.4000003zm.4-10.4000003h-1.2v4.8l4.16 2.5600003.64-1.04-3.6-2.1600003z"/></svg>
				<time class="entry-meta-date updated" datetime="0001-01-01 00:00:00 &#43;0000 UTC">January 01, 0001</time>
			</p>
		</header>
		<div class="entry-content clearfix">
			
			

<h1 id="nginx-ingress">nginx-ingress</h1>

<p><a href="https://github.com/kubernetes/ingress-nginx">nginx-ingress</a> is an Ingress controller that uses ConfigMap to store the nginx configuration.</p>

<p>To use, add the <code>kubernetes.io/ingress.class: nginx</code> annotation to your Ingress resources.</p>

<h2 id="tl-dr">TL;DR;</h2>

<pre><code class="language-console">$ helm install stable/nginx-ingress
</code></pre>

<h2 id="introduction">Introduction</h2>

<p>This chart bootstraps an nginx-ingress deployment on a <a href="http://kubernetes.io">Kubernetes</a> cluster using the <a href="https://helm.sh">Helm</a> package manager.</p>

<h2 id="prerequisites">Prerequisites</h2>

<ul>
<li>Kubernetes 1.6+</li>
</ul>

<h2 id="installing-the-chart">Installing the Chart</h2>

<p>To install the chart with the release name <code>my-release</code>:</p>

<pre><code class="language-console">$ helm install --name my-release stable/nginx-ingress
</code></pre>

<p>The command deploys nginx-ingress on the Kubernetes cluster in the default configuration. The <a href="#configuration">configuration</a> section lists the parameters that can be configured during installation.</p>

<blockquote>
<p><strong>Tip</strong>: List all releases using <code>helm list</code></p>
</blockquote>

<h2 id="uninstalling-the-chart">Uninstalling the Chart</h2>

<p>To uninstall/delete the <code>my-release</code> deployment:</p>

<pre><code class="language-console">$ helm delete my-release
</code></pre>

<p>The command removes all the Kubernetes components associated with the chart and deletes the release.</p>

<h2 id="configuration">Configuration</h2>

<p>The following table lists the configurable parameters of the nginx-ingress chart and their default values.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>controller.name</code></td>
<td>name of the controller component</td>
<td><code>controller</code></td>
</tr>

<tr>
<td><code>controller.image.repository</code></td>
<td>controller container image repository</td>
<td><code>quay.io/kubernetes-ingress-controller/nginx-ingress-controller</code></td>
</tr>

<tr>
<td><code>controller.image.tag</code></td>
<td>controller container image tag</td>
<td><code>0.18.0</code></td>
</tr>

<tr>
<td><code>controller.image.pullPolicy</code></td>
<td>controller container image pull policy</td>
<td><code>IfNotPresent</code></td>
</tr>

<tr>
<td><code>controller.config</code></td>
<td>nginx ConfigMap entries</td>
<td>none</td>
</tr>

<tr>
<td><code>controller.hostNetwork</code></td>
<td>If the nginx deployment / daemonset should run on the host&rsquo;s network namespace. Do not set this when <code>controller.service.externalIPs</code> is set and <code>kube-proxy</code> is used as there will be a port-conflict for port <code>80</code></td>
<td>false</td>
</tr>

<tr>
<td><code>controller.defaultBackendService</code></td>
<td>default 404 backend service; required only if <code>defaultBackend.enabled = false</code></td>
<td><code>&quot;&quot;</code></td>
</tr>

<tr>
<td><code>controller.electionID</code></td>
<td>election ID to use for the status update</td>
<td><code>ingress-controller-leader</code></td>
</tr>

<tr>
<td><code>controller.extraEnvs</code></td>
<td>any additional environment variables to set in the pods</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>controller.extraContainers</code></td>
<td>Sidecar containers to add to the controller pod. See <a href="https://github.com/lemonldap-ng-controller/lemonldap-ng-controller">LemonLDAP::NG controller</a> as example</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>controller.extraVolumeMounts</code></td>
<td>Additional volumeMounts to the controller main container</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>controller.extraVolumes</code></td>
<td>Additional volumes to the controller pod</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>controller.extraInitContainers</code></td>
<td>Containers, which are run before the app containers are started</td>
<td><code>[]</code></td>
</tr>

<tr>
<td><code>controller.ingressClass</code></td>
<td>name of the ingress class to route through this controller</td>
<td><code>nginx</code></td>
</tr>

<tr>
<td><code>controller.scope.enabled</code></td>
<td>limit the scope of the ingress controller</td>
<td><code>false</code> (watch all namespaces)</td>
</tr>

<tr>
<td><code>controller.scope.namespace</code></td>
<td>namespace to watch for ingress</td>
<td><code>&quot;&quot;</code> (use the release namespace)</td>
</tr>

<tr>
<td><code>controller.extraArgs</code></td>
<td>Additional controller container arguments</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>controller.kind</code></td>
<td>install as Deployment or DaemonSet</td>
<td><code>Deployment</code></td>
</tr>

<tr>
<td><code>controller.daemonset.useHostPort</code></td>
<td>If <code>controller.kind</code> is <code>DaemonSet</code>, this will enable <code>hostPort</code> for TCP/80 and TCP/443</td>
<td>false</td>
</tr>

<tr>
<td><code>controller.daemonset.hostPorts.http</code></td>
<td>If <code>controller.daemonset.useHostPort</code> is <code>true</code> and this is non-empty, it sets the hostPort</td>
<td><code>&quot;80&quot;</code></td>
</tr>

<tr>
<td><code>controller.daemonset.hostPorts.https</code></td>
<td>If <code>controller.daemonset.useHostPort</code> is <code>true</code> and this is non-empty, it sets the hostPort</td>
<td><code>&quot;443&quot;</code></td>
</tr>

<tr>
<td><code>controller.tolerations</code></td>
<td>node taints to tolerate (requires Kubernetes &gt;=1.6)</td>
<td><code>[]</code></td>
</tr>

<tr>
<td><code>controller.affinity</code></td>
<td>node/pod affinities (requires Kubernetes &gt;=1.6)</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>controller.minReadySeconds</code></td>
<td>how many seconds a pod needs to be ready before killing the next, during update</td>
<td><code>0</code></td>
</tr>

<tr>
<td><code>controller.nodeSelector</code></td>
<td>node labels for pod assignment</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>controller.podAnnotations</code></td>
<td>annotations to be added to pods</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>controller.podLabels</code></td>
<td>labels to add to the pod container metadata</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>controller.replicaCount</code></td>
<td>desired number of controller pods</td>
<td><code>1</code></td>
</tr>

<tr>
<td><code>controller.minAvailable</code></td>
<td>minimum number of available controller pods for PodDisruptionBudget</td>
<td><code>1</code></td>
</tr>

<tr>
<td><code>controller.resources</code></td>
<td>controller pod resource requests &amp; limits</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>controller.priorityClassName</code></td>
<td>controller priorityClassName</td>
<td><code>nil</code></td>
</tr>

<tr>
<td><code>controller.lifecycle</code></td>
<td>controller pod lifecycle hooks</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>controller.service.annotations</code></td>
<td>annotations for controller service</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>controller.service.labels</code></td>
<td>labels for controller service</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>controller.publishService.enabled</code></td>
<td>if true, the controller will set the endpoint records on the ingress objects to reflect those on the service</td>
<td><code>false</code></td>
</tr>

<tr>
<td><code>controller.publishService.pathOverride</code></td>
<td>override of the default publish-service name</td>
<td><code>&quot;&quot;</code></td>
</tr>

<tr>
<td><code>controller.service.clusterIP</code></td>
<td>internal controller cluster service IP</td>
<td><code>&quot;&quot;</code></td>
</tr>

<tr>
<td><code>controller.service.externalIPs</code></td>
<td>controller service external IP addresses. Do not set this when <code>controller.hostNetwork</code> is set to <code>true</code> and <code>kube-proxy</code> is used as there will be a port-conflict for port <code>80</code></td>
<td><code>[]</code></td>
</tr>

<tr>
<td><code>controller.service.externalTrafficPolicy</code></td>
<td>If <code>controller.service.type</code> is <code>NodePort</code> or <code>LoadBalancer</code>, set this to <code>Local</code> to enable <a href="https://kubernetes.io/docs/tutorials/services/source-ip/#source-ip-for-services-with-typenodeport">source IP preservation</a></td>
<td><code>&quot;Cluster&quot;</code></td>
</tr>

<tr>
<td><code>controller.service.healthCheckNodePort</code></td>
<td>If <code>controller.service.type</code> is <code>NodePort</code> or <code>LoadBalancer</code> and <code>controller.service.externalTrafficPolicy</code> is set to <code>Local</code>, set this to <a href="https://kubernetes.io/docs/tutorials/services/source-ip/#source-ip-for-services-with-typenodeport">the managed health-check port the kube-proxy will expose</a>. If blank, a random port in the <code>NodePort</code> range will be assigned</td>
<td><code>&quot;&quot;</code></td>
</tr>

<tr>
<td><code>controller.service.loadBalancerIP</code></td>
<td>IP address to assign to load balancer (if supported)</td>
<td><code>&quot;&quot;</code></td>
</tr>

<tr>
<td><code>controller.service.loadBalancerSourceRanges</code></td>
<td>list of IP CIDRs allowed access to load balancer (if supported)</td>
<td><code>[]</code></td>
</tr>

<tr>
<td><code>controller.service.enableHttp</code></td>
<td>if port 80 should be opened for service</td>
<td><code>true</code></td>
</tr>

<tr>
<td><code>controller.service.enableHttps</code></td>
<td>if port 443 should be opened for service</td>
<td><code>true</code></td>
</tr>

<tr>
<td><code>controller.service.targetPorts.http</code></td>
<td>Sets the targetPort that maps to the Ingress&rsquo; port 80</td>
<td><code>80</code></td>
</tr>

<tr>
<td><code>controller.service.targetPorts.https</code></td>
<td>Sets the targetPort that maps to the Ingress&rsquo; port 443</td>
<td><code>443</code></td>
</tr>

<tr>
<td><code>controller.service.type</code></td>
<td>type of controller service to create</td>
<td><code>LoadBalancer</code></td>
</tr>

<tr>
<td><code>controller.service.nodePorts.http</code></td>
<td>If <code>controller.service.type</code> is <code>NodePort</code> and this is non-empty, it sets the nodePort that maps to the Ingress&rsquo; port 80</td>
<td><code>&quot;&quot;</code></td>
</tr>

<tr>
<td><code>controller.service.nodePorts.https</code></td>
<td>If <code>controller.service.type</code> is <code>NodePort</code> and this is non-empty, it sets the nodePort that maps to the Ingress&rsquo; port 443</td>
<td><code>&quot;&quot;</code></td>
</tr>

<tr>
<td><code>controller.livenessProbe.initialDelaySeconds</code></td>
<td>Delay before liveness probe is initiated</td>
<td>10</td>
</tr>

<tr>
<td><code>controller.livenessProbe.periodSeconds</code></td>
<td>How often to perform the probe</td>
<td>10</td>
</tr>

<tr>
<td><code>controller.livenessProbe.timeoutSeconds</code></td>
<td>When the probe times out</td>
<td>5</td>
</tr>

<tr>
<td><code>controller.livenessProbe.successThreshold</code></td>
<td>Minimum consecutive successes for the probe to be considered successful after having failed.</td>
<td>1</td>
</tr>

<tr>
<td><code>controller.livenessProbe.failureThreshold</code></td>
<td>Minimum consecutive failures for the probe to be considered failed after having succeeded.</td>
<td>3</td>
</tr>

<tr>
<td><code>controller.livenessProbe.port</code></td>
<td>The port number that the liveness probe will listen on.</td>
<td>10254</td>
</tr>

<tr>
<td><code>controller.readinessProbe.initialDelaySeconds</code></td>
<td>Delay before readiness probe is initiated</td>
<td>10</td>
</tr>

<tr>
<td><code>controller.readinessProbe.periodSeconds</code></td>
<td>How often to perform the probe</td>
<td>10</td>
</tr>

<tr>
<td><code>controller.readinessProbe.timeoutSeconds</code></td>
<td>When the probe times out</td>
<td>1</td>
</tr>

<tr>
<td><code>controller.readinessProbe.successThreshold</code></td>
<td>Minimum consecutive successes for the probe to be considered successful after having failed.</td>
<td>1</td>
</tr>

<tr>
<td><code>controller.readinessProbe.failureThreshold</code></td>
<td>Minimum consecutive failures for the probe to be considered failed after having succeeded.</td>
<td>3</td>
</tr>

<tr>
<td><code>controller.readinessProbe.port</code></td>
<td>The port number that the readiness probe will listen on.</td>
<td>10254</td>
</tr>

<tr>
<td><code>controller.stats.enabled</code></td>
<td>if <code>true</code>, enable &ldquo;vts-status&rdquo; page</td>
<td><code>false</code></td>
</tr>

<tr>
<td><code>controller.stats.service.annotations</code></td>
<td>annotations for controller stats service</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>controller.stats.service.clusterIP</code></td>
<td>internal controller stats cluster service IP</td>
<td><code>&quot;&quot;</code></td>
</tr>

<tr>
<td><code>controller.stats.service.externalIPs</code></td>
<td>controller service stats external IP addresses</td>
<td><code>[]</code></td>
</tr>

<tr>
<td><code>controller.stats.service.loadBalancerIP</code></td>
<td>IP address to assign to load balancer (if supported)</td>
<td><code>&quot;&quot;</code></td>
</tr>

<tr>
<td><code>controller.stats.service.loadBalancerSourceRanges</code></td>
<td>list of IP CIDRs allowed access to load balancer (if supported)</td>
<td><code>[]</code></td>
</tr>

<tr>
<td><code>controller.stats.service.type</code></td>
<td>type of controller stats service to create</td>
<td><code>ClusterIP</code></td>
</tr>

<tr>
<td><code>controller.metrics.enabled</code></td>
<td>if <code>true</code>, enable Prometheus metrics (<code>controller.stats.enabled</code> must be <code>true</code> as well)</td>
<td><code>false</code></td>
</tr>

<tr>
<td><code>controller.metrics.service.annotations</code></td>
<td>annotations for Prometheus metrics service</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>controller.metrics.service.clusterIP</code></td>
<td>cluster IP address to assign to service</td>
<td><code>&quot;&quot;</code></td>
</tr>

<tr>
<td><code>controller.metrics.service.externalIPs</code></td>
<td>Prometheus metrics service external IP addresses</td>
<td><code>[]</code></td>
</tr>

<tr>
<td><code>controller.metrics.service.loadBalancerIP</code></td>
<td>IP address to assign to load balancer (if supported)</td>
<td><code>&quot;&quot;</code></td>
</tr>

<tr>
<td><code>controller.metrics.service.loadBalancerSourceRanges</code></td>
<td>list of IP CIDRs allowed access to load balancer (if supported)</td>
<td><code>[]</code></td>
</tr>

<tr>
<td><code>controller.metrics.service.servicePort</code></td>
<td>Prometheus metrics service port</td>
<td><code>9913</code></td>
</tr>

<tr>
<td><code>controller.metrics.service.type</code></td>
<td>type of Prometheus metrics service to create</td>
<td><code>ClusterIP</code></td>
</tr>

<tr>
<td><code>controller.customTemplate.configMapName</code></td>
<td>configMap containing a custom nginx template</td>
<td><code>&quot;&quot;</code></td>
</tr>

<tr>
<td><code>controller.customTemplate.configMapKey</code></td>
<td>configMap key containing the nginx template</td>
<td><code>&quot;&quot;</code></td>
</tr>

<tr>
<td><code>controller.headers</code></td>
<td>configMap key:value pairs containing the <a href="https://github.com/kubernetes/ingress-nginx/tree/master/docs/examples/customization/custom-headers">custom headers</a> for Nginx</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>controller.updateStrategy</code></td>
<td>allows setting of RollingUpdate strategy</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>defaultBackend.enabled</code></td>
<td>If false, controller.defaultBackendService must be provided</td>
<td><code>true</code></td>
</tr>

<tr>
<td><code>defaultBackend.name</code></td>
<td>name of the default backend component</td>
<td><code>default-backend</code></td>
</tr>

<tr>
<td><code>defaultBackend.image.repository</code></td>
<td>default backend container image repository</td>
<td><code>k8s.gcr.io/defaultbackend</code></td>
</tr>

<tr>
<td><code>defaultBackend.image.tag</code></td>
<td>default backend container image tag</td>
<td><code>1.4</code></td>
</tr>

<tr>
<td><code>defaultBackend.image.pullPolicy</code></td>
<td>default backend container image pull policy</td>
<td><code>IfNotPresent</code></td>
</tr>

<tr>
<td><code>defaultBackend.extraArgs</code></td>
<td>Additional default backend container arguments</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>defaultBackend.port</code></td>
<td>Http port number</td>
<td><code>8080</code></td>
</tr>

<tr>
<td><code>defaultBackend.tolerations</code></td>
<td>node taints to tolerate (requires Kubernetes &gt;=1.6)</td>
<td><code>[]</code></td>
</tr>

<tr>
<td><code>defaultBackend.affinity</code></td>
<td>node/pod affinities (requires Kubernetes &gt;=1.6)</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>defaultBackend.nodeSelector</code></td>
<td>node labels for pod assignment</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>defaultBackend.podAnnotations</code></td>
<td>annotations to be added to pods</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>defaultBackend.podLabels</code></td>
<td>labels to add to the pod container metadata</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>defaultBackend.replicaCount</code></td>
<td>desired number of default backend pods</td>
<td><code>1</code></td>
</tr>

<tr>
<td><code>defaultBackend.minAvailable</code></td>
<td>minimum number of available default backend pods for PodDisruptionBudget</td>
<td><code>1</code></td>
</tr>

<tr>
<td><code>defaultBackend.resources</code></td>
<td>default backend pod resource requests &amp; limits</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>defaultBackend.priorityClassName</code></td>
<td>default backend  priorityClassName</td>
<td><code>nil</code></td>
</tr>

<tr>
<td><code>defaultBackend.service.annotations</code></td>
<td>annotations for default backend service</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>defaultBackend.service.clusterIP</code></td>
<td>internal default backend cluster service IP</td>
<td><code>&quot;&quot;</code></td>
</tr>

<tr>
<td><code>defaultBackend.service.externalIPs</code></td>
<td>default backend service external IP addresses</td>
<td><code>[]</code></td>
</tr>

<tr>
<td><code>defaultBackend.service.loadBalancerIP</code></td>
<td>IP address to assign to load balancer (if supported)</td>
<td><code>&quot;&quot;</code></td>
</tr>

<tr>
<td><code>defaultBackend.service.loadBalancerSourceRanges</code></td>
<td>list of IP CIDRs allowed access to load balancer (if supported)</td>
<td><code>[]</code></td>
</tr>

<tr>
<td><code>defaultBackend.service.type</code></td>
<td>type of default backend service to create</td>
<td><code>ClusterIP</code></td>
</tr>

<tr>
<td><code>imagePullSecrets</code></td>
<td>name of Secret resource containing private registry credentials</td>
<td><code>nil</code></td>
</tr>

<tr>
<td><code>rbac.create</code></td>
<td>if <code>true</code>, create &amp; use RBAC resources</td>
<td><code>true</code></td>
</tr>

<tr>
<td><code>podSecurityPolicy.enabled</code></td>
<td>if <code>true</code>, create &amp; use Pod Security Policy resources</td>
<td><code>false</code></td>
</tr>

<tr>
<td><code>serviceAccount.create</code></td>
<td>if <code>true</code>, create a service account</td>
<td>``</td>
</tr>

<tr>
<td><code>serviceAccount.name</code></td>
<td>The name of the service account to use. If not set and <code>create</code> is <code>true</code>, a name is generated using the fullname template.</td>
<td>``</td>
</tr>

<tr>
<td><code>revisionHistoryLimit</code></td>
<td>The number of old history to retain to allow rollback.</td>
<td><code>10</code></td>
</tr>

<tr>
<td><code>tcp</code></td>
<td>TCP service key:value pairs</td>
<td><code>{}</code></td>
</tr>

<tr>
<td><code>udp</code></td>
<td>UDP service key:value pairs</td>
<td><code>{}</code></td>
</tr>
</tbody>
</table>

<pre><code class="language-console">$ helm install stable/nginx-ingress --name my-release \
    --set controller.stats.enabled=true
</code></pre>

<p>Alternatively, a YAML file that specifies the values for the parameters can be provided while installing the chart. For example,</p>

<pre><code class="language-console">$ helm install stable/nginx-ingress --name my-release -f values.yaml
</code></pre>

<p>A useful trick to debug issues with ingress is to increase the logLevel
as described <a href="https://github.com/kubernetes/ingress-nginx/blob/master/docs/troubleshooting.md#debug">here</a></p>

<pre><code class="language-console">$ helm install stable/nginx-ingress --set controller.extraArgs.v=2
</code></pre>

<h2 id="poddisruptionbudget">PodDisruptionBudget</h2>

<p>Note that the PodDisruptionBudget resource will only be defined if the replicaCount is greater than one,
else it would make it impossible to evacuate a node. See <a href="https://github.com/helm/charts/issues/7127">gh issue #7127</a> for more info.</p>

<h2 id="prometheus-metrics">Prometheus Metrics</h2>

<p>The Nginx ingress controller can export Prometheus metrics. In order for this to work, the VTS dashboard must be enabled as well.</p>

<pre><code class="language-console">$ helm install stable/nginx-ingress --name my-release \
    --set controller.stats.enabled=true \
    --set controller.metrics.enabled=true
</code></pre>

<p>You can add Prometheus annotations to the metrics service using <code>controller.metrics.service.annotations</code>. Alternatively, if you use the Prometheus Operator, you need to create a ServiceMonitor as follows:</p>

<pre><code class="language-yaml">apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: nginx-ingress-service-monitor
spec:
  jobLabel: nginx-ingress
  selector:
    matchLabels:
      app: nginx-ingress
      release: &lt;RELEASE&gt;
  namespaceSelector:
    matchNames:
      - &lt;RELEASE_NAMESPACE&gt;
  endpoints:
    - port: metrics
      interval: 30s
</code></pre>

<blockquote>
<p><strong>Tip</strong>: You can use the default <a href="values.yaml">values.yaml</a></p>
</blockquote>

<h2 id="externaldns-service-configuration">ExternalDNS Service configuration</h2>

<p>Add an <a href="https://github.com/kubernetes-incubator/external-dns">ExternalDNS</a> annotation to the LoadBalancer service:</p>

<pre><code class="language-yaml">annotations:
  external-dns.alpha.kubernetes.io/hostname: kubernetes-example.com.
</code></pre>

<h2 id="aws-l7-elb-with-ssl-termination">AWS L7 ELB with SSL Termination</h2>

<p>Annotate the controller as shown in the <a href="https://github.com/kubernetes/ingress-nginx/blob/master/deploy/provider/aws/service-l7.yaml">nginx-ingress l7 patch</a>:</p>

<pre><code class="language-yaml">controller:
  service:
    targetPorts:
      http: http
      https: http
    annotations:
      service.beta.kubernetes.io/aws-load-balancer-ssl-cert: arn:aws:acm:XX-XXXX-X:XXXXXXXXX:certificate/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXX
      service.beta.kubernetes.io/aws-load-balancer-backend-protocol: &quot;http&quot;
      service.beta.kubernetes.io/aws-load-balancer-ssl-ports: &quot;https&quot;
      service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout: '3600'
</code></pre>

<h2 id="aws-route53-mapper">AWS route53-mapper</h2>

<p>To configure the LoadBalancer service with the <a href="https://github.com/kubernetes/kops/tree/master/addons/route53-mapper">route53-mapper addon</a>, add the <code>domainName</code> annotation and <code>dns</code> label:</p>

<pre><code class="language-yaml">controller:
  service:
    labels:
      dns: &quot;route53&quot;
    annotations:
      domainName: &quot;kubernetes-example.com&quot;
</code></pre>

		</div>
		
	</article>
	
<div class="mr-author-box clearfix">
	<figure class="mr-author-box-avatar">
		<img alt="dishui avatar" src="/src/img/dishui.png" class="avatar avatar-90 photo" height="90" width="90">
	</figure>
	<div class="mr-author-box-header">
		<span class="mr-author-box-name">About dishui</span>
	</div>
	<div class="mr-author-box-bio">
		辛勤的搬运工!!!
	</div>
</div>

	

	<nav class="mr-post-nav mr-row clearfix" itemscope="itemscope" itemtype="http://schema.org/SiteNavigationElement">
		
		<div class="mr-col-1-2 mr-post-nav-item mr-post-nav-prev">
			<a href="/src/k8s/helm/nfs-client-provisioner/README/" rel="prev"><span>«Previous</span><p></p></a>
		</div>
		
		
		<div class="mr-col-1-2 mr-post-nav-item mr-post-nav-next">
			<a href="/src/k8s/helm/prometheus/README/" rel="next"><span>Next»</span><p></p></a>
		</div>
		
	</nav>


	
</div>

<aside class="mr-sidebar" itemscope="itemscope" itemtype="http://schema.org/WPSideBar">
<div class="mr-widget widget_search navbar-wrapper" >
    <div class="search-form">
        <label>
            <span class="screen-reader-text">Search for:</span>
            <input id="lanren" type="text" class="search-field" placeholder="Search..." value="" name="q">
        </label>
        <div id="list-container" class="bdsug" style="height: auto; display: block;">
        </div>
    </div>
    <div id="side-toc" class="entry-content">

    </div>
</div>
</aside>
	</div>
		<div class="mr-copyright-wrap">
			<div class="mr-container mr-container-inner clearfix">
				<p class="mr-copyright">&copy; 2019 零零碎碎. <a href="https://git.oschina.net/dishui/dishui" target="_blank" rel="nofollow noopener noreferrer">dishui</a>.</p>
			</div>
		</div>
	</div>

<script>
	var navigation = responsiveNav(".menu", {
		navClass: "menu--collapse",
	});
</script>
<script src="/js/asciinema-player.js"></script>
<script data-main="/js/app.js" src="/js/require.js"></script>


</body>
</html>