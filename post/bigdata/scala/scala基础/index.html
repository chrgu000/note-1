<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>scala基础</title>
<meta name="description" content=" John Doe&#39;s Personal blog about everything">
<meta name="generator" content="Hugo 0.17" />
<meta property="og:title" content="scala基础" />
<meta property="og:description" content="scala基础1. Scala基础1.1. 声明变量1.2. 常用类型1.3. 条件表达式1.4. 块表达式1.5. 循环1.6. 调用方法和函数1.7. 定义方法和函数1.7.1. 定义方法1.7.2. 定义函数1.7.3. 方法和函数的区别1.7.4. 将方法转换成函数（神奇的下划线）2. 数组、映射、元组、集合2.1. 数组2.1.1. 定长数组和变长数组2.1.2. 遍历数组2.1.3. 数组转换2.1.4. 数组常用算法2.2. 映射2.2.1. 构建映射2.2.2. 获取和修改映射中的值2.3. 元组2.3.1. 创建元组2.3.2. 获取元组中的值2.3.3. 将对偶的集合转换成映射2.3.4. 拉链操作2.4. 集合2.4.1. 序列2.5. Set2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/bigdata/scala/scala%E5%9F%BA%E7%A1%80/" />


<meta property="og:updated_time" content="2017-04-04T15:25:28&#43;00:00"/>











<link rel="stylesheet" href="/css/google-font.css?family=Open+Sans:400,400italic,700,600" type="text/css" media="all" />

<link rel="stylesheet" href="/css/railscasts.css">
<link rel="stylesheet" href="/css/style.css" type="text/css" media="all" />
<link rel="stylesheet" href="/css/custom.css" type="text/css" media="all" />
<link rel="stylesheet" href="/css/jquery.bigautocomplete.css" type="text/css" media="all" />
<link rel="stylesheet" href="/css/asciinema-player.css" type="text/css" media="all" />
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/fonts/fontawesome-webfont.svg" rel="stylesheet">

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script type="text/javascript" src="/js/scripts.js"></script>
<!--[if lt IE 9]>
	<script src="/js/css3-mediaqueries.js"></script>
<![endif]-->

</head>
<body id="mr-mobile" class="home blog mr-right-sb" itemscope="itemscope" itemtype="http://schema.org/WebPage">
	<div class="mr-container mr-container-outer">
		<div class="mr-header-mobile-nav clearfix"></div>
			<header class="mr-header" itemscope="itemscope" itemtype="http://schema.org/WPHeader">
				<div class="mr-container mr-container-inner mr-row clearfix">
					<div class="mr-custom-header clearfix">
						<div class="mr-site-identity">
							<div class="mr-site-logo" role="banner" itemscope="itemscope" itemtype="http://schema.org/Brand">
								<div class="mr-header-text">
									<a class="mr-header-text-link" href="/" title="零零碎碎" rel="home">
										<h1 class="mr-header-title">零零碎碎</h1>
										<h2 class="mr-header-tagline">点滴记录</h2>
									</a>
								</div>
							</div>
						</div>
					</div>
				</div>
				<div class="mr-main-nav-wrap">
					<nav class="menu" itemscope="itemscope" itemtype="http://schema.org/SiteNavigationElement">
	<ul class="menu__list">
        
            <li class="menu__item"><a class="menu__link" href="/categories/docker">docker</a></li>
        
            <li class="menu__item"><a class="menu__link" href="/categories/hadoop">hadoop</a></li>
        
            <li class="menu__item"><a class="menu__link" href="/categories/scala">scala</a></li>
        
            <li class="menu__item"><a class="menu__link" href="/categories/spark">spark</a></li>
        
	</ul>
</nav>
				</div>
			</header>
		<div class="mr-wrapper clearfix">


<div class="mr-content" id="main-content" role="main" itemprop="mainContentOfPage">
	<article class="post">
		<header class="entry-header clearfix">
			<h1 class="entry-title">scala基础</h1>
			<p class="mr-meta entry-meta">
				<svg class="icon icon-time" height="14" viewBox="0 0 16 16" width="14" xmlns="http://www.w3.org/2000/svg"><path d="m8-.0000003c-4.4 0-8 3.6-8 8 0 4.4000003 3.6 8.0000003 8 8.0000003 4.4 0 8-3.6 8-8.0000003 0-4.4-3.6-8-8-8zm0 14.4000003c-3.52 0-6.4-2.88-6.4-6.4000003 0-3.52 2.88-6.4 6.4-6.4 3.52 0 6.4 2.88 6.4 6.4 0 3.5200003-2.88 6.4000003-6.4 6.4000003zm.4-10.4000003h-1.2v4.8l4.16 2.5600003.64-1.04-3.6-2.1600003z"/></svg>
				<time class="entry-meta-date updated" datetime="2017-04-04 15:25:28 &#43;0000 UTC">April 04, 2017</time>
				<span class="entry-meta-categories">
					<svg class="icon icon-category" height="16" viewBox="0 0 16 16" width="16" xmlns="http://www.w3.org/2000/svg"><path d="m7 2l1 2h8v11h-16v-13z"/></svg>
					<a class="meta-categories" href="/categories/scala" rel="category">scala</a></span>
			</p>
		</header>
		<div class="entry-content clearfix">
			
			<div id="toc" class="toc">
<div id="toctitle">scala基础</div>
<ul class="sectlevel1">
<li><a href="#_scala基础">1. Scala基础</a>
<ul class="sectlevel2">
<li><a href="#_声明变量">1.1. 声明变量</a></li>
<li><a href="#_常用类型">1.2. 常用类型</a></li>
<li><a href="#_条件表达式">1.3. 条件表达式</a></li>
<li><a href="#_块表达式">1.4. 块表达式</a></li>
<li><a href="#_循环">1.5. 循环</a></li>
<li><a href="#_调用方法和函数">1.6. 调用方法和函数</a></li>
<li><a href="#_定义方法和函数">1.7. 定义方法和函数</a>
<ul class="sectlevel3">
<li><a href="#_定义方法">1.7.1. 定义方法</a></li>
<li><a href="#_定义函数">1.7.2. 定义函数</a></li>
<li><a href="#_方法和函数的区别">1.7.3. 方法和函数的区别</a></li>
<li><a href="#_将方法转换成函数_神奇的下划线">1.7.4. 将方法转换成函数（神奇的下划线）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_数组_映射_元组_集合">2. 数组、映射、元组、集合</a>
<ul class="sectlevel2">
<li><a href="#_数组">2.1. 数组</a>
<ul class="sectlevel3">
<li><a href="#_定长数组和变长数组">2.1.1. 定长数组和变长数组</a></li>
<li><a href="#_遍历数组">2.1.2. 遍历数组</a></li>
<li><a href="#_数组转换">2.1.3. 数组转换</a></li>
<li><a href="#_数组常用算法">2.1.4. 数组常用算法</a></li>
</ul>
</li>
<li><a href="#_映射">2.2. 映射</a>
<ul class="sectlevel3">
<li><a href="#_构建映射">2.2.1. 构建映射</a></li>
<li><a href="#_获取和修改映射中的值">2.2.2. 获取和修改映射中的值</a></li>
</ul>
</li>
<li><a href="#_元组">2.3. 元组</a>
<ul class="sectlevel3">
<li><a href="#_创建元组">2.3.1. 创建元组</a></li>
<li><a href="#_获取元组中的值">2.3.2. 获取元组中的值</a></li>
<li><a href="#_将对偶的集合转换成映射">2.3.3. 将对偶的集合转换成映射</a></li>
<li><a href="#_拉链操作">2.3.4. 拉链操作</a></li>
</ul>
</li>
<li><a href="#_集合">2.4. 集合</a>
<ul class="sectlevel3">
<li><a href="#_序列">2.4.1. 序列</a></li>
</ul>
</li>
<li><a href="#_set">2.5. Set</a></li>
<li><a href="#_map">2.6. Map</a></li>
</ul>
</li>
<li><a href="#_类_对象_继承_特质">3. 类、对象、继承、特质</a>
<ul class="sectlevel2">
<li><a href="#_类">3.1. 类</a>
<ul class="sectlevel3">
<li><a href="#_类的定义">3.1.1. 类的定义</a></li>
<li><a href="#_构造器">3.1.2. 构造器</a></li>
</ul>
</li>
<li><a href="#_对象">3.2. 对象</a>
<ul class="sectlevel3">
<li><a href="#_单例对象">3.2.1. 单例对象</a></li>
<li><a href="#_伴生对象">3.2.2. 伴生对象</a></li>
<li><a href="#_apply方法">3.2.3. apply方法</a></li>
<li><a href="#_应用程序对象">3.2.4. 应用程序对象</a></li>
</ul>
</li>
<li><a href="#_继承">3.3. 继承</a>
<ul class="sectlevel3">
<li><a href="#_扩展类">3.3.1. 扩展类</a></li>
<li><a href="#_重写方法">3.3.2. 重写方法</a></li>
<li><a href="#_类型检查和转换">3.3.3. 类型检查和转换</a></li>
<li><a href="#_超类的构造">3.3.4. 超类的构造</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_模式匹配和样例类">4. 模式匹配和样例类</a>
<ul class="sectlevel2">
<li><a href="#_匹配字符串">4.1. 匹配字符串</a></li>
<li><a href="#_匹配类型">4.2. 匹配类型</a></li>
<li><a href="#_匹配数组_元组">4.3. 匹配数组、元组</a></li>
<li><a href="#_样例类">4.4. 样例类</a></li>
<li><a href="#_option类型">4.5. Option类型</a></li>
<li><a href="#_偏函数">4.6. 偏函数</a></li>
</ul>
</li>
<li><a href="#_单机版_wordcount">5. 单机版 wordcount</a></li>
<li><a href="#_参考">6. 参考</a></li>
<li><a href="#_sbt_idea搭建阅读spark源码">7. SBT+IDEA搭建阅读Spark源码</a>
<ul class="sectlevel2">
<li><a href="#_配置sbt">7.1. 配置SBT</a></li>
<li><a href="#_idea">7.2. IDEA</a></li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_scala基础">1. Scala基础</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_声明变量">1.1. 声明变量</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>object VariableDemo {
  def main(args: Array[String]) {
    //使用val定义的变量值是不可变的，相当于java里用final修饰的变量
    val i = 1
    //使用var定义的变量是可变得，在Scala中鼓励使用val
    var s = "hello"
    //Scala编译器会自动推断变量的类型，必要的时候可以指定类型
    //变量名在前，类型在后
    val str: String = "itcast"
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_常用类型">1.2. 常用类型</h3>
<div class="paragraph">
<p><strong>Scala</strong> 和 <strong>Java</strong> 一样，有7种数值类型 <strong>Byte</strong> 、 <strong>Char</strong> 、 <strong>Short</strong> 、 <strong>Int</strong> 、 <strong>Long</strong> 、 <strong>Float</strong> 和 <strong>Double</strong> （无包装类型）和一个 <strong>Boolean</strong> 类型</p>
</div>
</div>
<div class="sect2">
<h3 id="_条件表达式">1.3. 条件表达式</h3>
<div class="paragraph">
<p>Scala的的条件表达式比较简洁，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>object ConditionDemo {
  def main(args: Array[String]) {
    val x = 1
    //判断x的值，将结果赋给y
    val y = if (x &gt; 0) 1 else -1
    //打印y的值
    println(y)

    //支持混合类型表达式
    val z = if (x &gt; 1) 1 else "error"
    //打印z的值
    println(z)

    //如果缺失else，相当于if (x &gt; 2) 1 else ()
    val m = if (x &gt; 2) 1
    println(m)

    //在scala中每个表达式都有值，scala中有个Unit类，写做(),相当于Java中的void
    val n = if (x &gt; 2) 1 else ()
    println(n)

    //if和else if
    val k = if (x &lt; 0) 0
    else if (x &gt;= 1) 1 else -1
    println(k)
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_块表达式">1.4. 块表达式</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>object BlockExpressionDemo {
  def main(args: Array[String]) {
    val x = 0
    //在scala中{}中课包含一系列表达式，块中最后一个表达式的值就是块的值
    //下面就是一个块表达式
    val result = {
      if (x &lt; 0){
        -1
      } else if(x &gt;= 1) {
        1
      } else {
        "error"
      }
    }
    //result的值就是块表达式的结果
    println(result)
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_循环">1.5. 循环</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>在scala中有for循环和while循环，用for循环比较多
for循环语法结构：for (i &#8592; 表达式/数组/集合)</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>object ForDemo {
  def main(args: Array[String]) {
    //for(i &lt;- 表达式),表达式1 to 10返回一个Range（区间）
    //每次循环将区间中的一个值赋给i
    for (i &lt;- 1 to 10)
      println(i)

    //for(i &lt;- 数组)
    val arr = Array("a", "b", "c")
    for (i &lt;- arr)
      println(i)

    //高级for循环
    //每个生成器都可以带一个条件，注意：if前面没有分号
    for(i &lt;- 1 to 3; j &lt;- 1 to 3 if i != j)
      print((10 * i + j) + " ")
    println()

    //for推导式：如果for循环的循环体以yield开始，则该循环会构建出一个集合
    //每次迭代生成集合中的一个值
    val v = for (i &lt;- 1 to 10) yield i * 10
    println(v)

  }

}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_调用方法和函数">1.6. 调用方法和函数</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Scala中的+ - * / %等操作符的作用与Java一样，位操作符 &amp; | ^ &gt;&gt; &lt;&lt;也一样。只是有
一点特别的：这些操作符实际上是方法。</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre>例如：
　　a + b
是如下方法调用的简写：
　　a. +(b)
a 方法 b可以写成 a.方法(b)</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_定义方法和函数">1.7. 定义方法和函数</h3>
<div class="sect3">
<h4 id="_定义方法">1.7.1. 定义方法</h4>
<div class="imageblock">
<div class="content">
<img src="/src/img/scala/2017-04-04_162650.png" alt="2017 04 04 162650">
</div>
</div>
<hr>
<div class="paragraph">
<p>方法的返回值类型可以不写，编译器可以自动推断出来，但是对于递归函数，必须指定返回类型</p>
</div>
</div>
<div class="sect3">
<h4 id="_定义函数">1.7.2. 定义函数</h4>
<div class="imageblock">
<div class="content">
<img src="/src/img/scala/2017-04-04_162701.png" alt="2017 04 04 162701">
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_方法和函数的区别">1.7.3. 方法和函数的区别</h4>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>在函数式编程语言中，函数是“头等公民”，它可以像任何其他数据类型一样被传递和操作</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>+
image::/src/img/scala/2017-04-04_162709.png[]
---
案例：首先定义一个方法，再定义一个函数，然后将函数传递到方法里面</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>object MethodAndFunctionDemo {
  //定义一个方法
  //方法m2参数要求是一个函数，函数的参数必须是两个Int类型
  //返回值类型也是Int类型
  def m1(f: (Int, Int) =&gt; Int) : Int = {
    f(2, 6)
  }

  //定义一个函数f1，参数是两个Int类型，返回值是一个Int类型
  val f1 = (x: Int, y: Int) =&gt; x + y
  //再定义一个函数f2
  val f2 = (m: Int, n: Int) =&gt; m * n

  //main方法
  def main(args: Array[String]) {

    //调用m1方法，并传入f1函数
    val r1 = m1(f1)
    println(r1)

    //调用m1方法，并传入f2函数
    val r2 = m1(f2)
    println(r2)
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_将方法转换成函数_神奇的下划线">1.7.4. 将方法转换成函数（神奇的下划线）</h4>
<div class="imageblock">
<div class="content">
<img src="/src/img/scala/2017-04-04_162717.png" alt="2017 04 04 162717">
</div>
</div>
<hr>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_数组_映射_元组_集合">2. 数组、映射、元组、集合</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_数组">2.1. 数组</h3>
<div class="sect3">
<h4 id="_定长数组和变长数组">2.1.1. 定长数组和变长数组</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>import scala.collection.mutable.ArrayBuffer
object ArrayDemo {

  def main(args: Array[String]) {

    //初始化一个长度为8的定长数组，其所有元素均为0
    val arr1 = new Array[Int](8)
    //直接打印定长数组，内容为数组的hashcode值
    println(arr1)
    //将数组转换成数组缓冲，就可以看到原数组中的内容了
    //toBuffer会将数组转换长数组缓冲
    println(arr1.toBuffer)

    //注意：如果new，相当于调用了数组的apply方法，直接为数组赋值
    //初始化一个长度为1的定长数组
    val arr2 = Array[Int](10)
    println(arr2.toBuffer)

    //定义一个长度为3的定长数组
    val arr3 = Array("hadoop", "storm", "spark")
    //使用()来访问元素
    println(arr3(2))

    //////////////////////////////////////////////////
    //变长数组（数组缓冲）
    //如果想使用数组缓冲，需要导入import scala.collection.mutable.ArrayBuffer包
    val ab = ArrayBuffer[Int]()
    //向数组缓冲的尾部追加一个元素
    //+=尾部追加元素
    ab += 1
    //追加多个元素
    ab += (2, 3, 4, 5)
    //追加一个数组++=
    ab ++= Array(6, 7)
    //追加一个数组缓冲
    ab ++= ArrayBuffer(8,9)
    //打印数组缓冲ab

    //在数组某个位置插入元素用insert
    ab.insert(0, -1, 0)
    //删除数组某个位置的元素用remove
    ab.remove(8, 2)
    println(ab)

  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_遍历数组">2.1.2. 遍历数组</h4>
<div class="paragraph">
<p>1.增强for循环
2.好用的until会生成脚标，0 until 10 包含0不包含10</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/src/img/scala/2017-04-04_162727.png" alt="2017 04 04 162727">
</div>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>object ForArrayDemo {

  def main(args: Array[String]) {
    //初始化一个数组
    val arr = Array(1,2,3,4,5,6,7,8)
    //增强for循环
    for(i &lt;- arr)
      println(i)

    //好用的until会生成一个Range
    //reverse是将前面生成的Range反转
    for(i &lt;- (0 until arr.length).reverse)
      println(arr(i))
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_数组转换">2.1.3. 数组转换</h4>
<div class="paragraph">
<p>yield关键字将原始的数组进行转换会产生一个新的数组，原始的数组不变</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/src/img/scala/2017-04-04_162736.png" alt="2017 04 04 162736">
</div>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>object ArrayYieldDemo {
  def main(args: Array[String]) {
    //定义一个数组
    val arr = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)
    //将偶数取出乘以10后再生成一个新的数组
    val res = for (e &lt;- arr if e % 2 == 0) yield e * 10
    println(res.toBuffer)

    //更高级的写法,用着更爽
    //filter是过滤，接收一个返回值为boolean的函数
    //map相当于将数组中的每一个元素取出来，应用传进去的函数
    val r = arr.filter(_ % 2 == 0).map(_ * 10)
    println(r.toBuffer)

  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_数组常用算法">2.1.4. 数组常用算法</h4>
<div class="paragraph">
<p>在Scala中，数组上的某些方法对数组进行相应的操作非常方便！</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/src/img/scala/2017-04-04_162743.png" alt="2017 04 04 162743">
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="_映射">2.2. 映射</h3>
<div class="paragraph">
<p>在Scala中，把哈希表这种数据结构叫做映射</p>
</div>
<div class="sect3">
<h4 id="_构建映射">2.2.1. 构建映射</h4>
<div class="imageblock">
<div class="content">
<img src="/src/img/scala/2017-04-04_162749.png" alt="2017 04 04 162749">
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_获取和修改映射中的值">2.2.2. 获取和修改映射中的值</h4>
<div class="imageblock">
<div class="content">
<img src="/src/img/scala/2017-04-04_162755.png" alt="2017 04 04 162755">
</div>
</div>
<hr>
<div class="paragraph">
<p>好用的getOrElse</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/src/img/scala/2017-04-04_162802.png" alt="2017 04 04 162802">
</div>
</div>
<hr>
<div class="paragraph">
<p>注意：在Scala中，有两种Map，一个是immutable包下的Map，该Map中的内容不可变；另一个是mutable包下的Map，该Map中的内容可变
例子：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/src/img/scala/2017-04-04_162812.png" alt="2017 04 04 162812">
</div>
</div>
<hr>
<div class="paragraph">
<p>注意：通常我们在创建一个集合是会用val这个关键字修饰一个变量（相当于java中的final），那么就意味着该变量的引用不可变，该引用中的内容是不是可变，取决于这个引用指向的集合的类型</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_元组">2.3. 元组</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>映射是K/V对偶的集合，对偶是元组的最简单形式，元组可以装着多个不同类型的值。</p>
</div>
</blockquote>
</div>
<div class="sect3">
<h4 id="_创建元组">2.3.1. 创建元组</h4>
<div class="imageblock">
<div class="content">
<img src="/src/img/scala/2017-04-04_162819.png" alt="2017 04 04 162819">
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_获取元组中的值">2.3.2. 获取元组中的值</h4>
<div class="imageblock">
<div class="content">
<img src="/src/img/scala/2017-04-04_162828.png" alt="2017 04 04 162828">
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_将对偶的集合转换成映射">2.3.3. 将对偶的集合转换成映射</h4>
<div class="imageblock">
<div class="content">
<img src="/src/img/scala/2017-04-04_162835.png" alt="2017 04 04 162835">
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_拉链操作">2.3.4. 拉链操作</h4>
<div class="paragraph">
<p>zip命令可以将多个值绑定在一起</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/src/img/scala/2017-04-04_162841.png" alt="2017 04 04 162841">
</div>
</div>
<hr>
<div class="paragraph">
<p>注意：如果两个数组的元素个数不一致，拉链操作后生成的数组的长度为较小的那个数组的元素个数</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_集合">2.4. 集合</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Scala的集合有三大类</dt>
<dd>
<p>序列Seq、集Set、映射Map，所有的集合都扩展自Iterable特质
在Scala中集合有可变（mutable）和不可变（immutable）两种类型，immutable类型的集合初始化后就不能改变了（注意与val修饰的变量进行区别）</p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="_序列">2.4.1. 序列</h4>
<div class="dlist">
<dl>
<dt class="hdlist1">不可变的序列 </dt>
<dd>
<p><code>import scala.collection.immutable._</code></p>
<div class="listingblock">
<div class="content">
<pre>在Scala中列表要么为空（Nil表示空列表）要么是一个head元素加上一个tail列表。
9 :: List(5, 2)  :: 操作符是将给定的头和尾创建一个新的列表
注意：:: 操作符是右结合的，如9 :: 5 :: 2 :: Nil相当于 9 :: (5 :: (2 :: Nil))</pre>
</div>
</div>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>object ImmutListDemo {

  def main(args: Array[String]) {
    //创建一个不可变的集合
    val lst1 = List(1,2,3)
    //将0插入到lst1的前面生成一个新的List
    val lst2 = 0 :: lst1
    val lst3 = lst1.::(0)
    val lst4 = 0 +: lst1
    val lst5 = lst1.+:(0)

    //将一个元素添加到lst1的后面产生一个新的集合
    val lst6 = lst1 :+ 3

    val lst0 = List(4,5,6)
    //将2个list合并成一个新的List
    val lst7 = lst1 ++ lst0
    //将lst1插入到lst0前面生成一个新的集合
    val lst8 = lst1 ++: lst0

    //将lst0插入到lst1前面生成一个新的集合
    val lst9 = lst1.:::(lst0)

    println(lst9)
  }
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">可变的序列 <code>import scala.collection.mutable._</code> </dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>import scala.collection.mutable.ListBuffer

object MutListDemo extends App{
  //构建一个可变列表，初始有3个元素1,2,3
  val lst0 = ListBuffer[Int](1,2,3)
  //创建一个空的可变列表
  val lst1 = new ListBuffer[Int]
  //向lst1中追加元素，注意：没有生成新的集合
  lst1 += 4
  lst1.append(5)

  //将lst1中的元素最近到lst0中， 注意：没有生成新的集合
  lst0 ++= lst1

  //将lst0和lst1合并成一个新的ListBuffer 注意：生成了一个集合
  val lst2= lst0 ++ lst1

  //将元素追加到lst0的后面生成一个新的集合
  val lst3 = lst0 :+ 5
}</code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_set">2.5. Set</h3>
<div class="listingblock">
<div class="title">不可变的Set</div>
<div class="content">
<pre class="highlightjs highlight"><code>import scala.collection.immutable.HashSet

object ImmutSetDemo extends App{
  val set1 = new HashSet[Int]()
  //将元素和set1合并生成一个新的set，原有set不变
  val set2 = set1 + 4
  //set中元素不能重复
  val set3 = set1 ++ Set(5, 6, 7)
  val set0 = Set(1,3,4) ++ set1
  println(set0.getClass)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">可变的Set</div>
<div class="content">
<pre class="highlightjs highlight"><code>import scala.collection.mutable

object MutSetDemo extends App{
  //创建一个可变的HashSet
  val set1 = new mutable.HashSet[Int]()
  //向HashSet中添加元素
  set1 += 2
  //add等价于+=
  set1.add(4)
  set1 ++= Set(1,3,5)
  println(set1)
  //删除一个元素
  set1 -= 5
  set1.remove(2)
  println(set1)
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_map">2.6. Map</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>import scala.collection.mutable

object MutMapDemo extends App{
  val map1 = new mutable.HashMap[String, Int]()
  //向map中添加数据
  map1("spark") = 1
  map1 += (("hadoop", 2))
  map1.put("storm", 3)
  println(map1)

  //从map中移除元素
  map1 -= "spark"
  map1.remove("hadoop")
  println(map1)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_类_对象_继承_特质">3. 类、对象、继承、特质</h2>
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Scala的类与Java、C++的类比起来更简洁，学完之后你会更爱Scala！！！</p>
</div>
</blockquote>
</div>
<div class="sect2">
<h3 id="_类">3.1. 类</h3>
<div class="sect3">
<h4 id="_类的定义">3.1.1. 类的定义</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>//在Scala中，类并不用声明为public。
//Scala源文件中可以包含多个类，所有这些类都具有公有可见性。
class Person {
  //用val修饰的变量是只读属性，有getter但没有setter
  //（相当与Java中用final修饰的变量）
  val id = "9527"

  //用var修饰的变量既有getter又有setter
  var age: Int = 18

  //类私有字段,只能在类的内部使用
  private var name: String = "唐伯虎"

  //对象私有字段,访问权限更加严格的，Person类的方法只能访问到当前对象的字段
  private[this] val pet = "小强"
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_构造器">3.1.2. 构造器</h4>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
主构造器会执行类定义中的所有语句
</td>
</tr>
</table>
</div>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>/**
  *每个类都有主构造器，主构造器的参数直接放置类名后面，与类交织在一起
  */
class Student(val name: String, val age: Int){
  //主构造器会执行类定义中的所有语句
  println("执行主构造器")

  try {
    println("读取文件")
    throw new IOException("io exception")
  } catch {
    case e: NullPointerException =&gt; println("打印异常Exception : " + e)
    case e: IOException =&gt; println("打印异常Exception : " + e)
  } finally {
    println("执行finally部分")
  }

  private var gender = "male"

  //用this关键字定义辅助构造器
  def this(name: String, age: Int, gender: String){
    //每个辅助构造器必须以主构造器或其他的辅助构造器的调用开始
    this(name, age)
    println("执行辅助构造器")
    this.gender = gender
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>/**
  *构造器参数可以不带val或var，如果不带val或var的参数至少被一个方法所使用，
  *那么它将会被提升为字段
  */
//在类名后面加private就变成了私有的
class Queen private(val name: String, prop: Array[String], private var age: Int = 18){

  println(prop.size)

  //prop被下面的方法使用后，prop就变成了不可变得对象私有字段，等同于private[this] val prop
  //如果没有被方法使用该参数将不被保存为字段，仅仅是一个可以被主构造器中的代码访问的普通参数
  def description = name + " is " + age + " years old with " + prop.toBuffer
}

object Queen{
  def main(args: Array[String]) {
    //私有的构造器，只有在其伴生对象中使用
    val q = new Queen("hatano", Array("蜡烛", "皮鞭"), 20)
    println(q.description())
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_对象">3.2. 对象</h3>
<div class="sect3">
<h4 id="_单例对象">3.2.1. 单例对象</h4>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>在Scala中没有静态方法和静态字段，但是可以使用object这个语法结构来达到同样的目的</p>
</div>
</blockquote>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>存放工具方法和常量</p>
</li>
<li>
<p>高效共享单个不可变的实例</p>
</li>
<li>
<p>单例模式</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>import scala.collection.mutable.ArrayBuffer

object SingletonDemo {
  def main(args: Array[String]) {
    //单例对象，不需要new，用【类名.方法】调用对象中的方法
    val session = SessionFactory.getSession()
    println(session)
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>object SessionFactory{
  //该部分相当于java中的静态块
  var counts = 5
  val sessions = new ArrayBuffer[Session]()
  while(counts &gt; 0){
    sessions += new Session
    counts -= 1
  }

  //在object中的方法相当于java中的静态方法
  def getSession(): Session ={
    sessions.remove(0)
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>class Session{

}</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_伴生对象">3.2.2. 伴生对象</h4>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>在Scala的类中，与类名相同的对象叫做伴生对象，类和伴生对象之间可以相互访问私有的方法和属性</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>class Dog {
  val id = 1
  private var name = "itcast"

  def printName(): Unit ={
    //在Dog类中可以访问伴生对象Dog的私有属性
    println(Dog.CONSTANT + name )
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>/**
  * 伴生对象
  */
object Dog {

  //伴生对象中的私有属性
  private val CONSTANT = "汪汪汪 : "

  def main(args: Array[String]) {
    val p = new Dog
    //访问私有的字段name
    p.name = "123"
    p.printName()
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_apply方法">3.2.3. apply方法</h4>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>通常我们会在类的伴生对象中定义apply方法，当遇到类名(参数1,&#8230;&#8203;参数n)时apply方法会被调用</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>object ApplyDemo {
  def main(args: Array[String]) {
    //调用了Array伴生对象的apply方法
    //def apply(x: Int, xs: Int*): Array[Int]
    //arr1中只有一个元素5
    val arr1 = Array(5)
    println(arr1.toBuffer)

    //new了一个长度为5的array，数组里面包含5个null
    var arr2 = new Array(5)
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_应用程序对象">3.2.4. 应用程序对象</h4>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Scala程序都必须从一个对象的main方法开始，可以通过扩展App特质，不写main方法。</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>object AppObjectDemo extends App{
  //不用写main方法
  println("I love you Scala")
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_继承">3.3. 继承</h3>
<div class="sect3">
<h4 id="_扩展类">3.3.1. 扩展类</h4>
<div class="paragraph">
<p>在Scala中扩展类的方式和Java一样都是使用extends关键字</p>
</div>
</div>
<div class="sect3">
<h4 id="_重写方法">3.3.2. 重写方法</h4>
<div class="paragraph">
<p>在Scala中重写一个非抽象的方法必须使用override修饰符</p>
</div>
</div>
<div class="sect3">
<h4 id="_类型检查和转换">3.3.3. 类型检查和转换</h4>
<div class="listingblock">
<div class="content">
<pre>Scala
Java
obj.isInstanceOf[C]
obj instanceof C
obj.asInstanceOf[C]
(C)obj
classOf[C]
C.class</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_超类的构造">3.3.4. 超类的构造</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>object ClazzDemo {
  def main(args: Array[String]) {
    //val h = new Human
    //println(h.fight)
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>trait Flyable{
  def fly(): Unit ={
    println("I can fly")
  }

  def fight(): String
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>abstract class Animal {
  def run(): Int
  val name: String
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>class Human extends Animal with Flyable{

  val name = "abc"

  //打印几次"ABC"?
  val t1,t2,(a, b, c) = {
    println("ABC")
    (1,2,3)
  }

  println(a)
  println(t1._1)

  //在Scala中重写一个非抽象方法必须用override修饰
  override def fight(): String = {
    "fight with 棒子"
  }
  //在子类中重写超类的抽象方法时，不需要使用override关键字，写了也可以
  def run(): Int = {
    1
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_模式匹配和样例类">4. 模式匹配和样例类</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Scala有一个十分强大的模式匹配机制，可以应用到很多场合：如switch语句、类型检查等。
并且Scala还提供了样例类，对模式匹配进行了优化，可以快速进行匹配</p>
</div>
<div class="sect2">
<h3 id="_匹配字符串">4.1. 匹配字符串</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>import scala.util.Random

object CaseDemo01 extends App{
  val arr = Array("YoshizawaAkiho", "YuiHatano", "AoiSola")
  val name = arr(Random.nextInt(arr.length))
  name match {
    case "YoshizawaAkiho" =&gt; println("吉泽老师...")
    case "YuiHatano" =&gt; println("波多老师...")
    case _ =&gt; println("真不知道你们在说什么...")
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_匹配类型">4.2. 匹配类型</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>import scala.util.Random

object CaseDemo01 extends App{
  //val v = if(x &gt;= 5) 1 else if(x &lt; 2) 2.0 else "hello"
  val arr = Array("hello", 1, 2.0, CaseDemo)
  val v = arr(Random.nextInt(4))
  println(v)
  v match {
    case x: Int =&gt; println("Int " + x)
    case y: Double if(y &gt;= 0) =&gt; println("Double "+ y)
    case z: String =&gt; println("String " + z)
    case _ =&gt; throw new Exception("not match exception")
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意：case y: Double if(y &gt;= 0) &#8658; &#8230;&#8203;
模式匹配的时候还可以添加守卫条件。如不符合守卫条件，将掉入case _中</p>
</div>
</div>
<div class="sect2">
<h3 id="_匹配数组_元组">4.3. 匹配数组、元组</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>object CaseDemo03 extends App{

  val arr = Array(1, 3, 5)
  arr match {
    case Array(1, x, y) =&gt; println(x + " " + y)
    case Array(0) =&gt; println("only 0")
    case Array(0, _*) =&gt; println("0 ...")
    case _ =&gt; println("something else")
  }

  val lst = List(3, -1)
  lst match {
    case 0 :: Nil =&gt; println("only 0")
    case x :: y :: Nil =&gt; println(s"x: $x y: $y")
    case 0 :: tail =&gt; println("0 ...")
    case _ =&gt; println("something else")
  }

  val tup = (2, 3, 7)
  tup match {
    case (1, x, y) =&gt; println(s"1, $x , $y")
    case (_, z, 5) =&gt; println(z)
    case  _ =&gt; println("else")
  }
}</code></pre>
</div>
</div>
<div class="openblock">
<div class="content">
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
在Scala中列表要么为空（Nil表示空列表）要么是一个head元素加上一个tail列表。<br>
9 :: List(5, 2)  :: 操作符是将给定的头和尾创建一个新的列表<br>
:: 操作符是右结合的，如9 :: 5 :: 2 :: Nil相当于 9 :: (5 :: (2 :: Nil))
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_样例类">4.4. 样例类</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>在Scala中样例类是一中特殊的类，可用于模式匹配。case class是多例的，后面要跟构造参数，case object是单例的</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>import scala.util.Random

case class SubmitTask(id: String, name: String)
case class HeartBeat(time: Long)
case object CheckTimeOutTask

object CaseDemo04 extends App{
  val arr = Array(CheckTimeOutTask, HeartBeat(12333), SubmitTask("0001", "task-0001"))

  arr(Random.nextInt(arr.length)) match {
    case SubmitTask(id, name) =&gt; {
      println(s"$id, $name")//前面需要加上s, $id直接取id的值
    }
    case HeartBeat(time) =&gt; {
      println(time)
    }
    case CheckTimeOutTask =&gt; {
      println("check")
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_option类型">4.5. Option类型</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>在Scala中Option类型样例类用来表示可能存在或也可能不存在的值(Option的子类有Some和None)。Some包装了某个值，None表示没有值</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>object OptionDemo {
  def main(args: Array[String]) {
    val map = Map("a" -&gt; 1, "b" -&gt; 2)
    val v = map.get("b") match {
      case Some(i) =&gt; i
      case None =&gt; 0
    }
    println(v)
    //更好的方式
    val v1 = map.getOrElse("c", 0)
    println(v1)
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_偏函数">4.6. 偏函数</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>被包在花括号内没有match的一组case语句是一个偏函数，它是PartialFunction[A, B]的一个实例，A代表参数类型，B代表返回类型，常用作输入模式匹配</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>object PartialFuncDemo  {

  def func1: PartialFunction[String, Int] = {
    case "one" =&gt; 1
    case "two" =&gt; 2
    case _ =&gt; -1
  }

  def func2(num: String) : Int = num match {
    case "one" =&gt; 1
    case "two" =&gt; 2
    case _ =&gt; -1
  }

  def main(args: Array[String]) {
    println(func1("one"))
    println(func2("one"))
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_单机版_wordcount">5. 单机版 wordcount</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>val lines = List("hello tom hello jerry","hello tom kitty hello hello")

lines.flatMap(_.split(" ")) <i class="conum" data-value="1"></i><b>(1)</b>
    .map((_,1)) <i class="conum" data-value="2"></i><b>(2)</b>
    .groupBy(_._1) <i class="conum" data-value="3"></i><b>(3)</b>
    .map(t =&gt; (t._1,t._2.size)) <i class="conum" data-value="4"></i><b>(4)</b>
    .toList.sortBy(_._2) <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>res2: List[String] = List(hello, tom, hello, jerry, hello, tom, kitty, hello, hello)</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>res4: List[(String, Int)] = Listhello,1), (tom,1), (hello,1), (jerry,1), (hello,1), (tom,1), (kitty,1), (hello,1), (hello,1</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>res5: scala.collection.immutable.Map[String,List[(String, Int)]] = Map(tom &#8594; Listtom,1), (tom,1, kitty &#8594; Listkitty,1, jerry &#8594; Listjerry,1, hello &#8594; Listhello,1), (hello,1), (hello,1), (hello,1), (hello,1)</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>res6: scala.collection.immutable.Map[String,Int] = Map(tom &#8594; 2, kitty &#8594; 1, jerry &#8594; 1, hello &#8594; 5)</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>res7: List[(String, Int)] = Listkitty,1), (jerry,1), (tom,2), (hello,5</code></td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code> lines.flatMap(_.split(" ")).map((_,1)).groupBy(_._1).mapValues(_.foldLeft(0)(_+_._2))</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_参考">6. 参考</h2>
<div class="sectionbody">
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="http://hongjiang.info/scala/" class="bare">http://hongjiang.info/scala/</a></p>
</li>
<li>
<p><a href="http://www.scalatest.org/quick_start">Scala单元测试</a></p>
</li>
<li>
<p><a href="http://guozhongxin.com/pages/2014/10/15/spark_source_code.html" class="bare">http://guozhongxin.com/pages/2014/10/15/spark_source_code.html</a></p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sbt_idea搭建阅读spark源码">7. SBT+IDEA搭建阅读Spark源码</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_配置sbt">7.1. 配置SBT</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>下载+
<a href="http://www.scala-sbt.org/download.html">sbt-0.13.15</a></p>
</li>
<li>
<p>windows下配置环境变量</p>
</li>
<li>
<p>阿里云仓库配置文件</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>$ ~/.sbt/repositories
[repositories]
  public: http://maven.aliyun.com/nexus/content/groups/public/
  typesafe:http://dl.bintray.com/typesafe/ivy-releases/, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext], bootOnly
  ivy-sbt-plugin:http://dl.bintray.com/sbt/sbt-plugin-releases/, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext]
  sonatype-oss-releases

  sonatype-oss-snapshots</code></pre>
</div>
</div>
</li>
<li>
<p>指定仓库</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>sbt -Dsbt.override.build.repos=true -Dsbt.repository.config=C:\Users\dishui\.sbt\repositories</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_idea">7.2. IDEA</h3>
<div class="imageblock">
<div class="content">
<img src="/src/img/spark/2017-05-04_112358.png" alt="2017 05 04 112358">
</div>
</div>
<hr>
<div class="imageblock">
<div class="content">
<img src="/src/img/spark/2017-05-04_112513.png" alt="2017 05 04 112513">
</div>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-XX:MaxPermSize=384M
-Dsbt.override.build.repos=true
-Dsbt.repository.config=C:\Users\dishui\.sbt\repositories</code></pre>
</div>
</div>
</div>
</div>
</div>

		</div>
		
	</article>
	
<div class="mr-author-box clearfix">
	<figure class="mr-author-box-avatar">
		<img alt="dishui avatar" src="/src/img/dishui.png" class="avatar avatar-90 photo" height="90" width="90">
	</figure>
	<div class="mr-author-box-header">
		<span class="mr-author-box-name">About dishui</span>
	</div>
	<div class="mr-author-box-bio">
		辛勤的搬运工!!!
	</div>
</div>

	

	<nav class="mr-post-nav mr-row clearfix" itemscope="itemscope" itemtype="http://schema.org/SiteNavigationElement">
		
		<div class="mr-col-1-2 mr-post-nav-item mr-post-nav-prev">
			<a href="/post/bigdata/scala/scala-Actor%E7%BC%96%E7%A8%8B/" rel="prev"><span>«Previous</span><p>Scala Actor编程</p></a>
		</div>
		
		
		<div class="mr-col-1-2 mr-post-nav-item mr-post-nav-next">
			<a href="/post/bigdata/storm/Kafka%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-%E8%87%AA%E5%AE%9A%E4%B9%89Partition-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/" rel="next"><span>Next»</span><p>Kafka负载均衡-自定义Partition-文件存储机制</p></a>
		</div>
		
	</nav>


	
</div>

<aside class="mr-sidebar" itemscope="itemscope" itemtype="http://schema.org/WPSideBar">
<div class="mr-widget widget_search navbar-wrapper" >
    <div class="search-form">
        <label>
            <span class="screen-reader-text">Search for:</span>
            <input id="lanren" type="text" class="search-field" placeholder="Search..." value="" name="q">
        </label>
        <div id="list-container" class="bdsug" style="height: auto; display: block;">
        </div>
    </div>
    <div id="side-toc" class="entry-content">

    </div>
</div>
</aside>
	</div>
		<div class="mr-copyright-wrap">
			<div class="mr-container mr-container-inner clearfix">
				<p class="mr-copyright">&copy; 2018 零零碎碎. <a href="https://git.oschina.net/dishui/dishui" target="_blank" rel="nofollow noopener noreferrer">dishui</a>.</p>
			</div>
		</div>
	</div>

<script>
	var navigation = responsiveNav(".menu", {
		navClass: "menu--collapse",
	});
</script>
<script src="/js/asciinema-player.js"></script>
<script data-main="/js/app.js" src="/js/require.js"></script>


</body>
</html>